var documenterSearchIndex = {"docs":
[{"location":"radial_orbitals/#Radial-orbitals","page":"Radial orbitals","title":"Radial orbitals","text":"","category":"section"},{"location":"radial_orbitals/","page":"Radial orbitals","title":"Radial orbitals","text":"CurrentModule = AtomicStructure\nDocTestSetup = quote\n    using AtomicStructure\nend","category":"page"},{"location":"radial_orbitals/","page":"Radial orbitals","title":"Radial orbitals","text":"RadialOrbital\nRadialOrbitals","category":"page"},{"location":"radial_orbitals/#AtomicStructure.RadialOrbital","page":"Radial orbitals","title":"AtomicStructure.RadialOrbital","text":"RadialOrbital\n\nA radial orbital is represented using basis coupled with a vector of expansion coefficients with respect to that basis; the basis implemented as an AbstractQuasimatrix.\n\n\n\n\n\n","category":"type"},{"location":"radial_orbitals/#AtomicStructure.RadialOrbitals","page":"Radial orbitals","title":"AtomicStructure.RadialOrbitals","text":"RadialOrbitals\n\nA collection of radial orbitals is instead represented using a matrix of such expansion coefficients, where each matrix column corresponds to a single radial orbital.\n\n\n\n\n\n","category":"type"},{"location":"radial_orbitals/","page":"Radial orbitals","title":"Radial orbitals","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"density_matrices/#Density-matrices","page":"Density matrices","title":"Density matrices","text":"","category":"section"},{"location":"density_matrices/","page":"Density matrices","title":"Density matrices","text":"The density matrix operator is defined as","category":"page"},{"location":"density_matrices/","page":"Density matrices","title":"Density matrices","text":"beginequation\nhatrho_ij defd ketbraij\nendequation","category":"page"},{"location":"density_matrices/","page":"Density matrices","title":"Density matrices","text":"If the wavefunction is approximated using Slater determinants, where one Slater determinant of N electrons is defined as","category":"page"},{"location":"density_matrices/","page":"Density matrices","title":"Density matrices","text":"beginequation\nPhi(123N) =\nfrac1sqrtN\nleftbeginmatrix\nchi_1(1)\nchi_2(2)\n\nchi_N(N)\nendmatrixright\nendequation","category":"page"},{"location":"density_matrices/","page":"Density matrices","title":"Density matrices","text":"where 123N denote the N different electronic coordinates (spatial and spin) and chi_i are the N different spin-orbitals, the transition density matrix for all N electrons, between two Slater determinants Phi_A and Phi_B is given by","category":"page"},{"location":"density_matrices/","page":"Density matrices","title":"Density matrices","text":"beginequation\nbeginaligned\nrho_N^AB(1N1N)\n=\nNPhi_A(1N)conjPhi_B(1N)\n=\nleftbeginmatrix\nrho_1(11)rho_1(1N)\nvdotsddotsvdots\nrho_1(N1)rho_1(NN)\nendmatrixright\nendaligned\nendequation","category":"page"},{"location":"density_matrices/#References","page":"Density matrices","title":"References","text":"","category":"section"},{"location":"density_matrices/","page":"Density matrices","title":"Density matrices","text":"Per-Olov Löwdin (1955). Quantum Theory of Many-Particle Systems. I. Physical Interpretations by Means of Density Matrices, Natural Spin-Orbitals, and Convergence Problems in the Method of Configurational Interaction. Physical Review, 97(6), 1474–1489. 10.1103/physrev.97.1474\nPer-Olov Löwdin (1955). Quantum Theory of Many-Particle Systems. II. Study of the Ordinary Hartree-Fock Approximation. Physical Review, 97(6), 1490–1508. 10.1103/physrev.97.1490\nPer-Olov Löwdin (1955). Quantum Theory of Many-Particle Systems. III. Extension of the Hartree-Fock Scheme to Include Degenerate Systems and Correlation Effects. Physical Review, 97(6), 1509–1520. 10.1103/physrev.97.1509","category":"page"},{"location":"atom_types/#Atom-types","page":"Atom types","title":"Atom types","text":"","category":"section"},{"location":"atom_types/","page":"Atom types","title":"Atom types","text":"CurrentModule = AtomicStructure\nDocTestSetup = quote\n    using AtomicStructure\nend","category":"page"},{"location":"atom_types/","page":"Atom types","title":"Atom types","text":"Atom\nAtom(::UndefInitializer, ::Type{T}, R::B, configurations::Vector{TC}, potential::P, ::Type{C}, mix_coeffs::CV=vcat(one(C), zeros(C, length(configurations)-1))) where {T<:Number,B<:BasisOrRestricted,TC,C,CV<:AbstractVector{<:C},P}\nAtom(init::Symbol, ::Type{T}, R::B, args...; kwargs...) where {T<:Number,B<:BasisOrRestricted,TC,C,P}\nAtom(init::Init, R::B, args...; kwargs...) where {Init,T,B<:AbstractQuasiMatrix{T}}\nAtom(R::B, configurations::Vector{<:TC}, potential::P, ::Type{C}=eltype(R), args...; kwargs...) where {B<:AbstractQuasiMatrix,TC<:ManyElectronWavefunction,C,P<:AbstractPotential}\nAtom(other_atom::Atom{T,B,O,TC,C,P}, configurations::Vector{<:TC}; kwargs...) where {T,B,O,TC,C,P}\nDiracAtom","category":"page"},{"location":"atom_types/#AtomicStructure.Atom","page":"Atom types","title":"AtomicStructure.Atom","text":"Atom(radial_orbitals, orbitals, configurations, mix_coeffs, potential)\n\nAn atom constitutes a set of single-electron orbitals with associated radial_orbitals, configurations which are ManyElectronWavefunction:s, comprising of anti-symmetrized combinations of such orbitals. The expansion coefficients mix_coeffs determine the linear combination of the configurations for multi-configurational atoms.\n\nThe potential can be used to model either the nucleus by itself (a point charge or a nucleus of finite extent) or the core orbitals (i.e. a pseudo-potential).\n\n\n\n\n\n","category":"type"},{"location":"atom_types/#AtomicStructure.Atom-Union{Tuple{P}, Tuple{CV}, Tuple{C}, Tuple{TC}, Tuple{B}, Tuple{T}, Tuple{UndefInitializer, Type{T}, B, Vector{TC}, P, Type{C}}, Tuple{UndefInitializer, Type{T}, B, Vector{TC}, P, Type{C}, CV}} where {T<:Number, B<:(Union{B, var\"#s5\"} where {B<:ContinuumArrays.Basis, var\"#s5\"<:(QuasiArrays.SubQuasiArray{<:Any, <:Any, <:B})}), TC, C, CV<:(AbstractVector{<:C}), P}","page":"Atom types","title":"AtomicStructure.Atom","text":"Atom(undef, ::Type{T}, R::AbstractQuasiMatrix, configurations, potential, ::Type{C}[, mix_coeffs])\n\nCreate an Atom on the space spanned by R, from the list of electronic configurations, with a nucleus modelled by potential, and leave the orbitals uninitialized. T determines the eltype of the radial orbitals and C the mixing coefficients, which by default, are initialized to [1,0,0,...].\n\n\n\n\n\n","category":"method"},{"location":"atom_types/#AtomicStructure.Atom-Union{Tuple{P}, Tuple{C}, Tuple{TC}, Tuple{B}, Tuple{T}, Tuple{Symbol, Type{T}, B, Vararg{Any}}} where {T<:Number, B<:(Union{B, var\"#s5\"} where {B<:ContinuumArrays.Basis, var\"#s5\"<:(QuasiArrays.SubQuasiArray{<:Any, <:Any, <:B})}), TC, C, P}","page":"Atom types","title":"AtomicStructure.Atom","text":"Atom(init, ::Type{T}, R::AbstractQuasiMatrix, configurations, potential, ::Type{C})\n\nCreate an Atom on the space spanned by R, from the list of electronic configurations, with a nucleus modelled by potential, and initialize the orbitals according to init. T determines the eltype of the radial orbitals and C the mixing coefficients.\n\n\n\n\n\n","category":"method"},{"location":"atom_types/#AtomicStructure.Atom-Union{Tuple{B}, Tuple{T}, Tuple{Init}, Tuple{Init, B, Vararg{Any}}} where {Init, T, B<:QuasiArrays.AbstractQuasiMatrix{T}}","page":"Atom types","title":"AtomicStructure.Atom","text":"Atom(init, R::AbstractQuasiMatrix, configurations, potential, ::Type{C})\n\nCreate an Atom on the space spanned by R, from the list of electronic configurations, with a nucleus modelled by potential, and initialize the orbitals according to init. C determines the eltype of the mixing coefficients.\n\n\n\n\n\n","category":"method"},{"location":"atom_types/#AtomicStructure.Atom-Union{Tuple{P}, Tuple{C}, Tuple{TC}, Tuple{B}, Tuple{B, Vector{<:TC}, P}, Tuple{B, Vector{<:TC}, P, Type{C}, Vararg{Any}}} where {B<:(QuasiArrays.AbstractQuasiMatrix), TC<:(Union{CSF{O}, SpinConfiguration} where O<:AbstractOrbital), C, P<:AbstractPotential}","page":"Atom types","title":"AtomicStructure.Atom","text":"Atom(R::AbstractQuasiMatrix, configurations, potential[, ::Type{C}=eltype(R)])\n\nCreate an Atom on the space spanned by R, from the list of electronic configurations, with a nucleus modelled by potential, and initialize the orbitals to their hydrogenic values.\n\n\n\n\n\n","category":"method"},{"location":"atom_types/#AtomicStructure.Atom-Union{Tuple{P}, Tuple{C}, Tuple{TC}, Tuple{O}, Tuple{B}, Tuple{T}, Tuple{Atom{T, B, O, TC, C, P}, Vector{<:TC}}} where {T, B, O, TC, C, P}","page":"Atom types","title":"AtomicStructure.Atom","text":"Atom(other_atom::Atom, configurations)\n\nCreate a new atom using the same basis and nuclear potential as other_atom, but with a different set of configurations. The orbitals of other_atom are copied over as starting guess.\n\n\n\n\n\n","category":"method"},{"location":"atom_types/#AtomicStructure.DiracAtom","page":"Atom types","title":"AtomicStructure.DiracAtom","text":"DiracAtom\n\nA DiracAtom is a specialization of Atom for the relativistic case.\n\n\n\n\n\n","category":"type"},{"location":"atom_types/","page":"Atom types","title":"Atom types","text":"getindex\nview\nnum_electrons","category":"page"},{"location":"atom_types/#Base.getindex","page":"Atom types","title":"Base.getindex","text":"getindex(atom, j)\n\nReturns a copy of the j:th radial orbital.\n\n\n\n\n\ngetindex(atom, orb)\n\nReturns a copy of the radial orbital corresponding to orb.\n\n\n\n\n\ngetindex(atom, js)\n\nReturns a copy of all radial orbitals with index ∈ js.\n\n\n\n\n\ngetindex(atom, orbs)\n\nReturns a copy of the radial orbitals corresponding to orbs.\n\n\n\n\n\n","category":"function"},{"location":"atom_types/#Base.view","page":"Atom types","title":"Base.view","text":"view(atom, j)\n\nReturns a view of the j:th radial orbital.\n\n\n\n\n\nview(atom, orb)\n\nReturns a view of the radial orbital corresponding to orb.\n\n\n\n\n\nview(atom, j)\n\nReturns a view of all radial orbitals with index ∈ js.\n\n\n\n\n\n","category":"function"},{"location":"atom_types/#AtomicLevels.num_electrons","page":"Atom types","title":"AtomicLevels.num_electrons","text":"num_electrons(atom)\n\nReturn number of electrons in atom.\n\n\n\n\n\n","category":"function"},{"location":"atom_types/#Internals","page":"Atom types","title":"Internals","text":"","category":"section"},{"location":"atom_types/","page":"Atom types","title":"Atom types","text":"CurrentModule = AtomicStructure","category":"page"},{"location":"atom_types/","page":"Atom types","title":"Atom types","text":"ManyElectronWavefunction\noutsidecoremodel\nall_bound\nSCF.coefficients\nSCF.orbitals","category":"page"},{"location":"atom_types/#AtomicStructure.ManyElectronWavefunction","page":"Atom types","title":"AtomicStructure.ManyElectronWavefunction","text":"ManyElectronWavefunction\n\nA many-electron wave function configuration can either be given as a CSF (summed over spins) or a configuration of spin-orbitals (where all quantum numbers are specified).\n\n\n\n\n\n","category":"type"},{"location":"atom_types/#AtomicStructure.outsidecoremodel","page":"Atom types","title":"AtomicStructure.outsidecoremodel","text":"outsidecoremodel(configuration::Configuration, potential::P)\n\nReturn the part of the electronic configuration that is not part of the the configuration modelled by the potential. For a point charge, this is the same as the configuration itself, but for pseudo-potentials, typically only the outer shells remain.\n\n\n\n\n\n","category":"function"},{"location":"atom_types/#AtomicStructure.all_bound","page":"Atom types","title":"AtomicStructure.all_bound","text":"all_bound(atom)\n\nReturns true if all orbitals in atom are bound orbitals.\n\n\n\n\n\n","category":"function"},{"location":"atom_types/#AtomicStructure.SCF.coefficients","page":"Atom types","title":"AtomicStructure.SCF.coefficients","text":"SCF.coefficients(atom)\n\nReturns a view of the mixing coefficients.\n\n\n\n\n\ncoefficients(quantum_system)\n\nRetrieves the mixing coefficients of quantum_system. Must return a view that the scf! routine can modify. To be overloaded by the implementation of AbstractQuantumSystem.\n\n\n\n\n\n","category":"function"},{"location":"atom_types/#AtomicStructure.SCF.orbitals","page":"Atom types","title":"AtomicStructure.SCF.orbitals","text":"SCF.orbitals(atom)\n\nReturns a view of the radial orbital coefficients (NB, it does not return the MulQuasiMatrix, but the actual underlying expansion coefficients, since SCF operates on them in the self-consistent iteration).\n\n\n\n\n\norbitals(quantum_system)\n\nRetrieves the orbitals of quantum_system. Must return a view that the scf! routine can modify. To be overloaded by the implementation of AbstractQuantumSystem.\n\n\n\n\n\n","category":"function"},{"location":"atom_types/","page":"Atom types","title":"Atom types","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To find the ground state of various atoms, we need a radial grid, a set of electronic configurations, and an atomic nucleus. AtomicStructure.jl does not yet support multi-configurational Hartree–Fock (it is implemented but not properly working, yet), and furthermore AngularMomentumAlgebra.jl can only derive energy expressions for Slater determinants at the moment, i.e. configuration state functions are not yet supported.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"First we load some required packages:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using AtomicStructure\nusing AtomicLevels\nusing SCF\n\nusing LinearAlgebra\nusing CompactBases\nusing IntervalSets","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can use the following function to quickly set up the radial grid:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"function get_atom_grid(grid_type, rₘₐₓ, ρ, nucleus; fedvr_order=10)\n    Z = charge(nucleus)\n    amend_order=nucleus isa PointCharge # For correct boundary\n                                        # conditions at r=0.\n\n    if grid_type == :fedvr\n        # FEDVR is more accurate, but can be expensive to use\n        N = max(ceil(Int, rₘₐₓ/(ρ*fedvr_order)),2)\n        t = range(0.0, stop=rₘₐₓ, length=N)\n        amended_order = vcat(fedvr_order+5, fill(fedvr_order,length(t)-2))\n        FEDVR(t, amend_order ? amended_order : fedvr_order)[:,2:end-1]\n    else\n        # Finite-differences are much lighter, but may require very\n        # fine grids to converge.\n        N = ceil(Int, rₘₐₓ/ρ + 1/2)\n        StaggeredFiniteDifferences(N, ρ)\n    end\nend","category":"page"},{"location":"examples/#Hydrogen","page":"Examples","title":"Hydrogen","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Since hydrogen can be solved exactly, no Hartree–Fock iterations are needed, and the orbital is in fact initialized to its hydrogenic shape upon construction:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> nucleus = pc\"H\"\nZ = 1 [hydrogen]\n\njulia> R = get_atom_grid(:fedvr, 10.0, 0.1, nucleus)\nFEDVR{Float64} basis with 9 elements on 0.0..10.0, restricted to basis functions 2..86 ⊂ 1..87\n\njulia> gst = ground_state(nucleus)\n1s\n\njulia> atom = Atom(R, [spin_configurations(gst)[1]], nucleus)\nAtom{Float64}(R=FEDVR{Float64} basis with 9 elements on 0.0..10.0, restricted to basis functions 2..86 ⊂ 1..87; Z = 1 [hydrogen]; 1 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Hydrogen orbital)","category":"page"},{"location":"examples/#Helium","page":"Examples","title":"Helium","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The setup is very similar to that of Hydrogen, but since helium has two electrons, it is a three-body problem which cannot be solved exactly. Instead, we make the mean-field approximation, where every electron is assumed to move independently in the potential formed from the nucleus and all other electrons:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We first make an initial guess, simply solving the hydrogen problem, but for the helium atomic nucleus with Z=2,\nWe then form an electron–electron repulsion potential for each electron, constructed from the other electron,\nWe use these potentials to solve for new electron orbitals.\nRepeat 2–3 until convergence.\nAdditionally, when the solution is converged enough, we can switch to non-linear optimization via Optim.jl, which is usually much faster. This is not strictly necessary for helium, but very helpful for heavier elements.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The initial setup is very similar to hydrogen:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> nucleus = pc\"He\"\nZ = 2 [helium]\n\njulia> R = get_atom_grid(:fedvr, 10.0, 0.1, nucleus)\nFEDVR{Float64} basis with 9 elements on 0.0..10.0, restricted to basis functions 2..86 ⊂ 1..87\n\njulia> gst = ground_state(nucleus)\n1s²\n\njulia> atom = Atom(R, [spin_configurations(gst)[1]], nucleus)\nAtom{Float64}(R=FEDVR{Float64} basis with 9 elements on 0.0..10.0, restricted to basis functions 2..86 ⊂ 1..87; Z = 2 [helium]; 2 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then we create a Fock operator, which will automatically form the energy expression and from that derive the orbital Hartree–Fock equations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> fock = Fock(atom)\nFock operator with\n- quantum system: Atom{Float64}(R=FEDVR{Float64} basis with 9 elements on 0.0..10.0, restricted to basis functions 2..86 ⊂ 1..87; Z = 2 [helium]; 2 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β\n- SCF equations:\n  - Hartree–Fock equation: E|1s₀α⟩ = OrbitalEquation(1s₀α):\n  [1, 1]  =  + 1ĥ₀|1s₀α⟩ + 1r⁻¹×Y⁰(1s₀β,1s₀β)|1s₀α⟩\n\n⟨1s₀α| 𝓗 |1s₀α⟩ = -0.7500000039950884 Ha = -20.408250108710348 eV\n\n  - Hartree–Fock equation: E|1s₀β⟩ = OrbitalEquation(1s₀β):\n  [1, 1]  =  + 1ĥ₀|1s₀β⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|1s₀β⟩\n\n⟨1s₀β| 𝓗 |1s₀β⟩ = -0.7500000039950884 Ha = -20.408250108710348 eV","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that the orbital energies pre-optimization corresponds to that of a 1s electron in a Z=2 potential. We are now ready to perform the optimization:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> optimize!(fock)\n[ Info: Performing initial SCF iterations\nSelf-Consistent-Field calculation of\n- Atom{Float64}(R=FEDVR{Float64} basis with 9 elements on 0.0..10.0, restricted to basis functions 2..86 ⊂ 1..87; Z = 2 [helium]; 2 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β\n- Maximum amount of iterations: 200\n- Stopping tolerance: 1.00×10⁻³\n\nIteration Tolerance  Energy                         ⟨T̂⟩           ⟨V̂⟩           ⟨V̂⟩/⟨T̂⟩ ⟨V̂⟩/⟨T̂⟩ + 2    Flags\n[  1/200] 3.84×10⁻²    -2.75000 Ha =  -74.83025 eV   +2.56003 Ha   -5.31003 Ha -2.07421 (7.42×10⁻² )\n[  2/200] 2.08×10⁻¹²   -2.85247 Ha =  -77.61859 eV   +2.56003 Ha   -5.41251 Ha -2.11423 (1.14×10⁻¹ )\n\nFinished in 0.06665205955505371 seconds\n┌───────┬────────────────────┬───────────────────┬───────────────────┐\n│ i – j │              ⟨i|j⟩ │           ⟨i|𝔣|j⟩ │           ⟨j|𝔣|i⟩ │\n├───────┼────────────────────┼───────────────────┼───────────────────┤\n│ 2 – 2 │ 0.9999999999999999 │ -0.94488715344265 │ -0.94488715344265 │\n│ 1 – 1 │ 0.9999999999999999 │ -0.94488715344265 │ -0.94488715344265 │\n└───────┴────────────────────┴───────────────────┴───────────────────┘\nIteration   |g|        Energy                         ⟨T̂⟩           ⟨V̂⟩           ⟨V̂⟩/⟨T̂⟩ ⟨V̂⟩/⟨T̂⟩ + 2    Flags\n[   1/1000] 3.15×10⁻¹    -2.85247 Ha =  -77.61859 eV   +2.56003 Ha   -5.41251 Ha -2.11423 (1.14×10⁻¹ )\n[   2/1000] 5.62×10⁻²    -2.85775 Ha =  -77.76214 eV   +2.77906 Ha   -5.63680 Ha -2.02832 (2.83×10⁻² )\n[   3/1000] 1.78×10⁻¹    -2.85867 Ha =  -77.78732 eV   +2.79272 Ha   -5.65139 Ha -2.02362 (2.36×10⁻² )\n[   4/1000] 2.87×10⁻¹    -2.85877 Ha =  -77.79001 eV   +2.79551 Ha   -5.65428 Ha -2.02263 (2.26×10⁻² )\n[   5/1000] 2.43×10⁻¹    -2.85889 Ha =  -77.79333 eV   +2.79827 Ha   -5.65716 Ha -2.02166 (2.17×10⁻² )\n[   6/1000] 1.40×10⁻¹    -2.85922 Ha =  -77.80224 eV   +2.80846 Ha   -5.66768 Ha -2.01807 (1.81×10⁻² )\n[   7/1000] 3.56×10⁻¹    -2.85932 Ha =  -77.80504 eV   +2.81610 Ha   -5.67542 Ha -2.01535 (1.53×10⁻² )\n[   8/1000] 1.06×10⁻¹    -2.85960 Ha =  -77.81245 eV   +2.83038 Ha   -5.68998 Ha -2.01032 (1.03×10⁻² )\n[   9/1000] 1.61×10⁻¹    -2.85981 Ha =  -77.81828 eV   +2.82407 Ha   -5.68388 Ha -2.01265 (1.27×10⁻² )\n[  10/1000] 1.70×10⁻¹    -2.85991 Ha =  -77.82088 eV   +2.82151 Ha   -5.68142 Ha -2.01361 (1.36×10⁻² )\n⁞\n[ 120/1000] 3.39×10⁻⁸    -2.86168 Ha =  -77.86917 eV   +2.86168 Ha   -5.72336 Ha -2.00000 (1.00×10⁻⁸ )\n[ 121/1000] 4.03×10⁻⁹    -2.86168 Ha =  -77.86917 eV   +2.86168 Ha   -5.72336 Ha -2.00000 (1.00×10⁻⁸ )\n  2.081946 seconds (3.29 M allocations: 256.888 MiB, 2.89% gc time)\n * Status: success\n\n * Candidate solution\n    Minimizer: [1.59e-02, 6.35e-02, 1.35e-01,  ...]\n    Minimum:   -2.861680e+00\n\n * Found with\n    Algorithm:     BFGS\n    Initial Point: [1.49e-02, 5.98e-02, 1.27e-01,  ...]\n\n * Convergence measures\n    |x - x'|               = 5.13e-10 ≰ 0.0e+00\n    |x - x'|/|x'|          = 1.59e-09 ≰ 0.0e+00\n    |f(x) - f(x')|         = 1.02e-14 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 3.57e-15 ≰ 0.0e+00\n    |g(x)|                 = 4.03e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   2  (vs limit Inf)\n    Iterations:    120\n    f(x) calls:    243\n    ∇f(x) calls:   244\n\nFinished in 2.150846004486084 seconds\n┌───────┬────────────────────┬─────────────────────┬─────────────────────┐\n│ i – j │              ⟨i|j⟩ │             ⟨i|𝔣|j⟩ │             ⟨j|𝔣|i⟩ │\n├───────┼────────────────────┼─────────────────────┼─────────────────────┤\n│ 2 – 2 │ 0.9999999999999997 │ -0.9179555568639189 │ -0.9179555568639189 │\n│ 1 – 1 │ 1.0000000000000002 │ -0.9179555568624107 │ -0.9179555568624107 │\n└───────┴────────────────────┴─────────────────────┴─────────────────────┘\nFock operator with\n- quantum system: Atom{Float64}(R=FEDVR{Float64} basis with 9 elements on 0.0..10.0, restricted to basis functions 2..86 ⊂ 1..87; Z = 2 [helium]; 2 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β\n- SCF equations:\n  - Hartree–Fock equation: E|1s₀α⟩ = OrbitalEquation(1s₀α):\n  [1, 1]  =  + 1ĥ₀|1s₀α⟩ + 1r⁻¹×Y⁰(1s₀β,1s₀β)|1s₀α⟩\n\n⟨1s₀α| 𝓗 |1s₀α⟩ = -0.9179555568624103 Ha = -24.978488657783043 eV\n\n  - Hartree–Fock equation: E|1s₀β⟩ = OrbitalEquation(1s₀β):\n  [1, 1]  =  + 1ĥ₀|1s₀β⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|1s₀β⟩\n\n⟨1s₀β| 𝓗 |1s₀β⟩ = -0.9179555568639188 Ha = -24.978488657824094 eV","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first section is the self-consistent iteration procedure described above, then the non-linear optimization refines the solution. The Hartree–Fock limit for helium is -28616800textrmHa, which we achieved!","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Helium orbitals)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Comparing with hydrogen, we see that the 1s orbitals are more contracted in helium, due to the larger nuclear charge. However, they are not as contracted as a single 1s electron in a Z=2 potential would be, due to the screening from the other electron.","category":"page"},{"location":"examples/#Beryllium","page":"Examples","title":"Beryllium","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In order to make the self-consistent iterations more stable, we introduce the successive-relaxation parameter omega; if w_i is the previous solution, and tildew the candidate solution, the new values are calculated as","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"w_i+1 = (1-ω)tildew + ωw_i","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For omega=0, the candidate solution is chosen, for all other values in the range (01), a mixture is chosen. This helps avoid oscillatory behaviour around local minima.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Additionally, since the 1s and 2s orbitals are non-orthogonal in the angular coordinates, orthogonality has to be enforced along the radial coordinate. This is accomplished via projectors in the self-consistent iterations together with explicit orbital rotations, to keep the Fock operator diagonal. In the non-linear optimization, optimization on Riemannian manifolds is used.","category":"page"},{"location":"examples/#FEDVR","page":"Examples","title":"FEDVR","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> nucleus = pc\"Be\"\nZ = 4 [beryllium]\n\njulia> R = get_atom_grid(:fedvr, 15.0, 0.1, nucleus)\nFEDVR{Float64} basis with 14 elements on 0.0..15.0, restricted to basis functions 2..131 ⊂ 1..132\n\njulia> gst = ground_state(nucleus)\n1s² 2s²\n\njulia> atom = Atom(R, [spin_configurations(gst)[1]], nucleus)\nAtom{Float64}(R=FEDVR{Float64} basis with 14 elements on 0.0..15.0, restricted to basis functions 2..131 ⊂ 1..132; Z = 4 [beryllium]; 4 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β 2s₀α 2s₀β\n\njulia> fock = Fock(atom)\nFock operator with\n- quantum system: Atom{Float64}(R=FEDVR{Float64} basis with 14 elements on 0.0..15.0, restricted to basis functions 2..131 ⊂ 1..132; Z = 4 [beryllium]; 4 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β 2s₀α 2s₀β\n- SCF equations:\n  - Hartree–Fock equation: E|1s₀α⟩ = OrbitalEquation(1s₀α):\n  [1, 1]  =  + 1ĥ₀|1s₀α⟩ + 1r⁻¹×Y⁰(1s₀β,1s₀β)|1s₀α⟩ … - 1r⁻¹×Y⁰(2s₀α,1s₀α)|2s₀α⟩ + 1r⁻¹×Y⁰(2s₀β,2s₀β)|1s₀α⟩\n\n⟨1s₀α| 𝓗 |1s₀α⟩ = -3.9087791916120778 Ha = -106.36179058295625 eV\n\n  - Hartree–Fock equation: E|1s₀β⟩ = OrbitalEquation(1s₀β):\n  [1, 1]  =  + 1ĥ₀|1s₀β⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|1s₀β⟩ … + 1r⁻¹×Y⁰(2s₀β,2s₀β)|1s₀β⟩ - 1r⁻¹×Y⁰(2s₀β,1s₀β)|2s₀β⟩\n\n⟨1s₀β| 𝓗 |1s₀β⟩ = -3.908779191612078 Ha = -106.36179058295626 eV\n\n  - Hartree–Fock equation: E|2s₀α⟩ = OrbitalEquation(2s₀α):\n  [1, 1]  =  + 1ĥ₀|2s₀α⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|2s₀α⟩ … + 1r⁻¹×Y⁰(1s₀β,1s₀β)|2s₀α⟩ + 1r⁻¹×Y⁰(2s₀β,2s₀β)|2s₀α⟩\n\n⟨2s₀α| 𝓗 |2s₀α⟩ = 0.19278329234852803 Ha = 5.245826168095796 eV\n\n  - Hartree–Fock equation: E|2s₀β⟩ = OrbitalEquation(2s₀β):\n  [1, 1]  =  + 1ĥ₀|2s₀β⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|2s₀β⟩ … - 1r⁻¹×Y⁰(1s₀β,2s₀β)|1s₀β⟩ + 1r⁻¹×Y⁰(2s₀α,2s₀α)|2s₀β⟩\n\n⟨2s₀β| 𝓗 |2s₀β⟩ = 0.19278329234852803 Ha = 5.245826168095796 eV\n\njulia> optimize!(fock,ω=0.999,ωmax=1-1e-3)\n[ Info: Performing initial SCF iterations\nSelf-Consistent-Field calculation of\n- Atom{Float64}(R=FEDVR{Float64} basis with 14 elements on 0.0..15.0, restricted to basis functions 2..131 ⊂ 1..132; Z = 4 [beryllium]; 4 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β 2s₀α 2s₀β\n- Maximum amount of iterations: 200\n- Stopping tolerance: 1.00×10⁻³\n- Successive relaxation: ω = 0.999\n\nIteration Tolerance  1-ω         Energy                         ⟨T̂⟩           ⟨V̂⟩           ⟨V̂⟩/⟨T̂⟩ ⟨V̂⟩/⟨T̂⟩ + 2    Flags\n[  1/200] 4.30×10⁻¹  1.00×10⁻³   -13.71600 Ha = -373.22596 eV  +19.99226 Ha  -33.70825 Ha -1.68607 (3.14×10⁻¹ )\n[  2/200] 4.29×10⁻¹  1.00×10⁻³   -13.71758 Ha = -373.26911 eV  +19.98485 Ha  -33.70243 Ha -1.68640 (3.14×10⁻¹ ) R\n[  3/200] 4.28×10⁻¹  1.00×10⁻³   -13.71913 Ha = -373.31132 eV  +19.97745 Ha  -33.69658 Ha -1.68673 (3.13×10⁻¹ ) R\n[  4/200] 4.27×10⁻¹  1.00×10⁻³   -13.72068 Ha = -373.35344 eV  +19.97006 Ha  -33.69074 Ha -1.68706 (3.13×10⁻¹ ) R\n[  5/200] 4.25×10⁻¹  1.00×10⁻³   -13.72222 Ha = -373.39546 eV  +19.96269 Ha  -33.68491 Ha -1.68739 (3.13×10⁻¹ ) R\n[  6/200] 4.24×10⁻¹  1.00×10⁻³   -13.72377 Ha = -373.43738 eV  +19.95533 Ha  -33.67909 Ha -1.68772 (3.12×10⁻¹ ) R\n[  7/200] 4.23×10⁻¹  1.00×10⁻³   -13.72530 Ha = -373.47920 eV  +19.94798 Ha  -33.67328 Ha -1.68805 (3.12×10⁻¹ ) R\n[  8/200] 4.21×10⁻¹  1.00×10⁻³   -13.72684 Ha = -373.52092 eV  +19.94064 Ha  -33.66748 Ha -1.68838 (3.12×10⁻¹ ) R\n[  9/200] 4.20×10⁻¹  1.00×10⁻³   -13.72837 Ha = -373.56255 eV  +19.93332 Ha  -33.66168 Ha -1.68871 (3.11×10⁻¹ ) R\n[ 10/200] 4.18×10⁻¹  1.01×10⁻¹   -13.72989 Ha = -373.60408 eV  +19.92600 Ha  -33.65590 Ha -1.68904 (3.11×10⁻¹ ) R\n[ 11/200] 4.17×10⁻¹  1.91×10⁻¹   -13.73141 Ha = -373.64552 eV  +19.20938 Ha  -32.94079 Ha -1.71483 (2.85×10⁻¹ ) R\n[ 12/200] 3.16×10⁻¹  2.72×10⁻¹   -13.87507 Ha = -377.55466 eV  +18.05594 Ha  -31.93101 Ha -1.76845 (2.32×10⁻¹ ) R\n[ 13/200] 1.30×10⁻¹  3.45×10⁻¹   -14.08097 Ha = -383.15728 eV  +16.85133 Ha  -30.93230 Ha -1.83560 (1.64×10⁻¹ ) R\n[ 14/200] 1.91×10⁻²  4.10×10⁻¹   -14.26919 Ha = -388.27893 eV  +15.86314 Ha  -30.13233 Ha -1.89952 (1.00×10⁻¹ ) R\n[ 15/200] 6.65×10⁻²  3.45×10⁻¹   -14.40575 Ha = -391.99490 eV  +15.18855 Ha  -29.59430 Ha -1.94846 (5.15×10⁻² ) R\n[ 16/200] 5.48×10⁻²  2.72×10⁻¹   -14.48906 Ha = -394.26184 eV  +14.90772 Ha  -29.39678 Ha -1.97192 (2.81×10⁻² ) R\n[ 17/200] 3.91×10⁻²  1.91×10⁻¹   -14.52224 Ha = -395.16458 eV  +14.79295 Ha  -29.31518 Ha -1.98170 (1.83×10⁻² ) R\n[ 18/200] 2.92×10⁻²  1.01×10⁻¹   -14.53737 Ha = -395.57624 eV  +14.74264 Ha  -29.28001 Ha -1.98608 (1.39×10⁻² ) R\n[ 19/200] 2.38×10⁻²  1.00×10⁻³   -14.54466 Ha = -395.77469 eV  +14.72277 Ha  -29.26743 Ha -1.98790 (1.21×10⁻² ) R\n[ 20/200] 2.15×10⁻²  1.00×10⁻³   -14.54770 Ha = -395.85739 eV  +14.72260 Ha  -29.27030 Ha -1.98812 (1.19×10⁻² ) R\n[ 21/200] 2.14×10⁻²  1.00×10⁻³   -14.54772 Ha = -395.85812 eV  +14.72244 Ha  -29.27016 Ha -1.98813 (1.19×10⁻² ) R\n[ 22/200] 2.14×10⁻²  1.00×10⁻³   -14.54775 Ha = -395.85885 eV  +14.72227 Ha  -29.27002 Ha -1.98815 (1.19×10⁻² ) R\n[ 23/200] 2.14×10⁻²  1.00×10⁻³   -14.54778 Ha = -395.85958 eV  +14.72210 Ha  -29.26988 Ha -1.98816 (1.18×10⁻² ) R\n[ 24/200] 2.14×10⁻²  1.01×10⁻¹   -14.54780 Ha = -395.86031 eV  +14.72194 Ha  -29.26974 Ha -1.98817 (1.18×10⁻² ) R\n[ 25/200] 2.14×10⁻²  1.91×10⁻¹   -14.54783 Ha = -395.86104 eV  +14.70519 Ha  -29.25302 Ha -1.98930 (1.07×10⁻² ) R\n[ 26/200] 1.92×10⁻²  2.72×10⁻¹   -14.55051 Ha = -395.93392 eV  +14.67672 Ha  -29.22723 Ha -1.99140 (8.60×10⁻³ ) R\n[ 27/200] 1.56×10⁻²  3.45×10⁻¹   -14.55499 Ha = -396.05594 eV  +14.64443 Ha  -29.19943 Ha -1.99389 (6.11×10⁻³ ) R\n[ 28/200] 1.14×10⁻²  4.10×10⁻¹   -14.56005 Ha = -396.19352 eV  +14.61572 Ha  -29.17577 Ha -1.99619 (3.81×10⁻³ ) R\n[ 29/200] 7.52×10⁻³  4.69×10⁻¹   -14.56461 Ha = -396.31766 eV  +14.59479 Ha  -29.15940 Ha -1.99793 (2.07×10⁻³ ) R\n[ 30/200] 4.45×10⁻³  5.22×10⁻¹   -14.56810 Ha = -396.41260 eV  +14.58217 Ha  -29.15027 Ha -1.99904 (9.65×10⁻⁴ )\n[ 31/200] 2.37×10⁻³  5.70×10⁻¹   -14.57042 Ha = -396.47578 eV  +14.57594 Ha  -29.14636 Ha -1.99962 (3.78×10⁻⁴ )\n[ 32/200] 1.13×10⁻³  6.13×10⁻¹   -14.57178 Ha = -396.51281 eV  +14.57357 Ha  -29.14535 Ha -1.99988 (1.22×10⁻⁴ )\n[ 33/200] 4.87×10⁻⁴  6.52×10⁻¹   -14.57249 Ha = -396.53204 eV  +14.57297 Ha  -29.14546 Ha -1.99997 (3.26×10⁻⁵ )\n\nFinished in 61.561668157577515 seconds\n┌───────┬───────────────────────┬───────────────────────┬────────────────────────┐\n│ i – j │                 ⟨i|j⟩ │               ⟨i|𝔣|j⟩ │                ⟨j|𝔣|i⟩ │\n├───────┼───────────────────────┼───────────────────────┼────────────────────────┤\n│ 2 – 2 │    0.9999956866353903 │    -4.732776785129098 │     -4.732776785129083 │\n│ 2 – 4 │   9.8612728676473e-10 │ 0.0002050777971931087 │ 0.00020507485106526969 │\n│ 4 – 4 │    0.9997331924711604 │   -0.3093444536176635 │   -0.30934445361767793 │\n│ 1 – 1 │    0.9999956866354134 │    -4.732776784904216 │    -4.7327767849042015 │\n│ 1 – 3 │ 9.861345986044206e-10 │ 0.0002050780474937991 │ 0.00020507510136494084 │\n│ 3 – 3 │    0.9997331924496939 │  -0.30934445298883984 │   -0.30934445298885427 │\n└───────┴───────────────────────┴───────────────────────┴────────────────────────┘\nIteration   |g|        Energy                         ⟨T̂⟩           ⟨V̂⟩           ⟨V̂⟩/⟨T̂⟩ ⟨V̂⟩/⟨T̂⟩ + 2    Flags\n[   1/1000] 2.12×10⁰    -14.57302 Ha = -396.54653 eV  +14.57297 Ha  -29.14599 Ha -2.00000 (3.88×10⁻⁶ )\n[   2/1000] 3.51×10⁻⁴   -14.57302 Ha = -396.54653 eV  +14.57379 Ha  -29.14682 Ha -1.99995 (5.29×10⁻⁵ )\n[   3/1000] 3.55×10⁻⁴   -14.57302 Ha = -396.54653 eV  +14.57380 Ha  -29.14682 Ha -1.99995 (5.33×10⁻⁵ )\n[   4/1000] 9.83×10⁻⁴   -14.57302 Ha = -396.54653 eV  +14.57380 Ha  -29.14682 Ha -1.99995 (5.30×10⁻⁵ )\n[   5/1000] 7.69×10⁻⁴   -14.57302 Ha = -396.54653 eV  +14.57375 Ha  -29.14677 Ha -1.99995 (4.96×10⁻⁵ )\n[   6/1000] 4.17×10⁻⁴   -14.57302 Ha = -396.54653 eV  +14.57373 Ha  -29.14676 Ha -1.99995 (4.88×10⁻⁵ )\n[   7/1000] 3.84×10⁻⁴   -14.57302 Ha = -396.54653 eV  +14.57372 Ha  -29.14674 Ha -1.99995 (4.78×10⁻⁵ )\n[   8/1000] 3.62×10⁻⁴   -14.57302 Ha = -396.54653 eV  +14.57371 Ha  -29.14674 Ha -1.99995 (4.75×10⁻⁵ )\n[   9/1000] 3.08×10⁻⁴   -14.57302 Ha = -396.54653 eV  +14.57367 Ha  -29.14670 Ha -1.99996 (4.47×10⁻⁵ )\n[  10/1000] 8.47×10⁻⁴   -14.57302 Ha = -396.54653 eV  +14.57366 Ha  -29.14669 Ha -1.99996 (4.40×10⁻⁵ )\n⁞\n[ 215/1000] 1.05×10⁻⁸   -14.57302 Ha = -396.54653 eV  +14.57303 Ha  -29.14605 Ha -2.00000 (2.46×10⁻⁷ )\n[ 216/1000] 8.73×10⁻⁹   -14.57302 Ha = -396.54653 eV  +14.57303 Ha  -29.14605 Ha -2.00000 (2.46×10⁻⁷ )\n 55.969735 seconds (45.75 M allocations: 4.256 GiB, 2.00% gc time)\n * Status: success\n\n * Candidate solution\n    Minimizer: [4.47e-02, 1.65e-01, 3.10e-01,  ...]\n    Minimum:   -1.457302e+01\n\n * Found with\n    Algorithm:     BFGS\n    Initial Point: [4.47e-02, 1.65e-01, 3.10e-01,  ...]\n\n * Convergence measures\n    |x - x'|               = 5.34e-10 ≰ 0.0e+00\n    |x - x'|/|x'|          = 1.19e-09 ≰ 0.0e+00\n    |f(x) - f(x')|         = 4.62e-14 ≰ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 3.17e-15 ≰ 0.0e+00\n    |g(x)|                 = 8.73e-09 ≤ 1.0e-08\n\n * Work counters\n    Seconds run:   56  (vs limit Inf)\n    Iterations:    215\n    f(x) calls:    434\n    ∇f(x) calls:   435\n\nFinished in 117.59166884422302 seconds\n┌───────┬────────────────────────┬────────────────────────┬────────────────────────┐\n│ i – j │                  ⟨i|j⟩ │                ⟨i|𝔣|j⟩ │                ⟨j|𝔣|i⟩ │\n├───────┼────────────────────────┼────────────────────────┼────────────────────────┤\n│ 2 – 2 │     0.9999999999999999 │    -4.7326681293957815 │    -4.7326681293957815 │\n│ 2 – 4 │  -6.94182183900668e-18 │  0.0001925532657846884 │  0.0001925504372876625 │\n│ 4 – 4 │     1.0000000000000002 │   -0.30926888559986515 │   -0.30926888559986515 │\n│ 1 – 1 │     0.9999999999999999 │     -4.732668129395627 │     -4.732668129395627 │\n│ 1 – 3 │ -1.226564706038428e-17 │ 0.00019255346268659193 │ 0.00019255063418685092 │\n│ 3 – 3 │     0.9999999999999998 │   -0.30926888559996896 │   -0.30926888559996896 │\n└───────┴────────────────────────┴────────────────────────┴────────────────────────┘\nFock operator with\n- quantum system: Atom{Float64}(R=FEDVR{Float64} basis with 14 elements on 0.0..15.0, restricted to basis functions 2..131 ⊂ 1..132; Z = 4 [beryllium]; 4 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β 2s₀α 2s₀β\n- SCF equations:\n  - Hartree–Fock equation: E|1s₀α⟩ = OrbitalEquation(1s₀α):\n  [1, 1]  =  + 1ĥ₀|1s₀α⟩ + 1r⁻¹×Y⁰(1s₀β,1s₀β)|1s₀α⟩ … - 1r⁻¹×Y⁰(2s₀α,1s₀α)|2s₀α⟩ + 1r⁻¹×Y⁰(2s₀β,2s₀β)|1s₀α⟩\n\n⟨1s₀α| 𝓗 |1s₀α⟩ = -4.732668129395628 Ha = -128.78063246898444 eV\n\n  - Hartree–Fock equation: E|1s₀β⟩ = OrbitalEquation(1s₀β):\n  [1, 1]  =  + 1ĥ₀|1s₀β⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|1s₀β⟩ … + 1r⁻¹×Y⁰(2s₀β,2s₀β)|1s₀β⟩ - 1r⁻¹×Y⁰(2s₀β,1s₀β)|2s₀β⟩\n\n⟨1s₀β| 𝓗 |1s₀β⟩ = -4.7326681293957815 Ha = -128.7806324689886 eV\n\n  - Hartree–Fock equation: E|2s₀α⟩ = OrbitalEquation(2s₀α):\n  [1, 1]  =  + 1ĥ₀|2s₀α⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|2s₀α⟩ … + 1r⁻¹×Y⁰(1s₀β,1s₀β)|2s₀α⟩ + 1r⁻¹×Y⁰(2s₀β,2s₀β)|2s₀α⟩\n\n⟨2s₀α| 𝓗 |2s₀α⟩ = -0.30926888559996896 Ha = -8.415515646060754 eV\n\n  - Hartree–Fock equation: E|2s₀β⟩ = OrbitalEquation(2s₀β):\n  [1, 1]  =  + 1ĥ₀|2s₀β⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|2s₀β⟩ … - 1r⁻¹×Y⁰(1s₀β,2s₀β)|1s₀β⟩ + 1r⁻¹×Y⁰(2s₀α,2s₀α)|2s₀β⟩\n\n⟨2s₀β| 𝓗 |2s₀β⟩ = -0.30926888559986515 Ha = -8.41551564605793 eV","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Beryllium FEDVR orbitals)","category":"page"},{"location":"examples/#Finite-differences","page":"Examples","title":"Finite-differences","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can repeat the same calculation using finite-differences instead of FEDVR. In this case, we have to switch from LOBPCG to Arnoldi iterations when solving the self-consistent problem, since the former is prone to errors in the Cholesky factorization if the grid is too coarse, whereas the latter struggle with too fine grids:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> nucleus = pc\"Be\"\nZ = 4 [beryllium]\n\njulia> R = get_atom_grid(:fd, 15.0, 0.1, nucleus)\nRadial finite differences basis {Float64} on 0.0..15.15 with 151 points spaced by ρ = 0.1\n\njulia> gst = ground_state(nucleus)\n1s² 2s²\n\njulia> atom = Atom(R, [spin_configurations(gst)[1]], nucleus)\nAtom{Float64}(R=Radial finite differences basis {Float64} on 0.0..15.15 with 151 points spaced by ρ = 0.1; Z = 4 [beryllium]; 4 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β 2s₀α 2s₀β\n\njulia> fock = Fock(atom)\nFock operator with\n- quantum system: Atom{Float64}(R=Radial finite differences basis {Float64} on 0.0..15.15 with 151 points spaced by ρ = 0.1; Z = 4 [beryllium]; 4 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β 2s₀α 2s₀β\n- SCF equations:\n  - Hartree–Fock equation: E|1s₀α⟩ = OrbitalEquation(1s₀α):\n  [1, 1]  =  + 1ĥ₀|1s₀α⟩ + 1r⁻¹×Y⁰(1s₀β,1s₀β)|1s₀α⟩ … - 1r⁻¹×Y⁰(2s₀α,1s₀α)|2s₀α⟩ + 1r⁻¹×Y⁰(2s₀β,2s₀β)|1s₀α⟩\n\n⟨1s₀α| 𝓗 |1s₀α⟩ = -3.9701516322712 Ha = -108.03179606573161 eV\n\n  - Hartree–Fock equation: E|1s₀β⟩ = OrbitalEquation(1s₀β):\n  [1, 1]  =  + 1ĥ₀|1s₀β⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|1s₀β⟩ … + 1r⁻¹×Y⁰(2s₀β,2s₀β)|1s₀β⟩ - 1r⁻¹×Y⁰(2s₀β,1s₀β)|2s₀β⟩\n\n⟨1s₀β| 𝓗 |1s₀β⟩ = -3.9701516322712 Ha = -108.03179606573161 eV\n\n  - Hartree–Fock equation: E|2s₀α⟩ = OrbitalEquation(2s₀α):\n  [1, 1]  =  + 1ĥ₀|2s₀α⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|2s₀α⟩ … + 1r⁻¹×Y⁰(1s₀β,1s₀β)|2s₀α⟩ + 1r⁻¹×Y⁰(2s₀β,2s₀β)|2s₀α⟩\n\n⟨2s₀α| 𝓗 |2s₀α⟩ = 0.17124757357291542 Ha = 4.659817724492601 eV\n\n  - Hartree–Fock equation: E|2s₀β⟩ = OrbitalEquation(2s₀β):\n  [1, 1]  =  + 1ĥ₀|2s₀β⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|2s₀β⟩ … - 1r⁻¹×Y⁰(1s₀β,2s₀β)|1s₀β⟩ + 1r⁻¹×Y⁰(2s₀α,2s₀α)|2s₀β⟩\n\n⟨2s₀β| 𝓗 |2s₀β⟩ = 0.17124757357291542 Ha = 4.659817724492601 eV\n\n\njulia> optimize!(fock,ω=0.999,ωmax=1-1e-3,scf_method=:arnoldi)\n[ Info: Performing initial SCF iterations\nSelf-Consistent-Field calculation of\n- Atom{Float64}(R=Radial finite differences basis {Float64} on 0.0..15.15 with 151 points spaced by ρ = 0.1; Z = 4 [beryllium]; 4 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β 2s₀α 2s₀β\n- Maximum amount of iterations: 200\n- Stopping tolerance: 1.00×10⁻³\n- Successive relaxation: ω = 0.999\n\nIteration Tolerance  1-ω         Energy                         ⟨T̂⟩           ⟨V̂⟩           ⟨V̂⟩/⟨T̂⟩ ⟨V̂⟩/⟨T̂⟩ + 2    Flags\n[  1/200] 4.16×10⁻¹  1.00×10⁻³   -13.79823 Ha = -375.46366 eV  +20.83039 Ha  -34.62862 Ha -1.66241 (3.38×10⁻¹ )\n[  2/200] 4.15×10⁻¹  1.00×10⁻³   -13.79976 Ha = -375.50517 eV  +20.82292 Ha  -34.62268 Ha -1.66272 (3.37×10⁻¹ ) R\n[  3/200] 4.13×10⁻¹  1.00×10⁻³   -13.80125 Ha = -375.54581 eV  +20.81546 Ha  -34.61671 Ha -1.66303 (3.37×10⁻¹ ) R\n[  4/200] 4.12×10⁻¹  1.00×10⁻³   -13.80274 Ha = -375.58636 eV  +20.80802 Ha  -34.61076 Ha -1.66334 (3.37×10⁻¹ ) R\n[  5/200] 4.11×10⁻¹  1.00×10⁻³   -13.80423 Ha = -375.62682 eV  +20.80059 Ha  -34.60481 Ha -1.66365 (3.36×10⁻¹ ) R\n[  6/200] 4.09×10⁻¹  1.00×10⁻³   -13.80571 Ha = -375.66718 eV  +20.79316 Ha  -34.59887 Ha -1.66395 (3.36×10⁻¹ ) R\n[  7/200] 4.08×10⁻¹  1.00×10⁻³   -13.80719 Ha = -375.70745 eV  +20.78575 Ha  -34.59295 Ha -1.66426 (3.36×10⁻¹ ) R\n[  8/200] 4.07×10⁻¹  1.00×10⁻³   -13.80867 Ha = -375.74763 eV  +20.77836 Ha  -34.58702 Ha -1.66457 (3.35×10⁻¹ ) R\n[  9/200] 4.05×10⁻¹  1.00×10⁻³   -13.81014 Ha = -375.78772 eV  +20.77097 Ha  -34.58111 Ha -1.66488 (3.35×10⁻¹ ) R\n[ 10/200] 4.04×10⁻¹  1.01×10⁻¹   -13.81161 Ha = -375.82772 eV  +20.76359 Ha  -34.57520 Ha -1.66518 (3.35×10⁻¹ ) R\n[ 11/200] 4.03×10⁻¹  1.91×10⁻¹   -13.81308 Ha = -375.86763 eV  +20.04038 Ha  -33.85346 Ha -1.68926 (3.11×10⁻¹ ) R\n[ 12/200] 3.05×10⁻¹  2.72×10⁻¹   -13.95161 Ha = -379.63715 eV  +18.86506 Ha  -32.81667 Ha -1.73955 (2.60×10⁻¹ ) R\n[ 13/200] 1.27×10⁻¹  3.45×10⁻¹   -14.15161 Ha = -385.07934 eV  +17.62484 Ha  -31.77645 Ha -1.80294 (1.97×10⁻¹ ) R\n[ 14/200] 1.70×10⁻²  4.10×10⁻¹   -14.33537 Ha = -390.07973 eV  +16.61120 Ha  -30.94657 Ha -1.86299 (1.37×10⁻¹ ) R\n[ 15/200] 6.41×10⁻²  3.45×10⁻¹   -14.46760 Ha = -393.67792 eV  +15.93288 Ha  -30.40048 Ha -1.90803 (9.20×10⁻² ) R\n[ 16/200] 5.34×10⁻²  2.72×10⁻¹   -14.54737 Ha = -395.84854 eV  +15.65666 Ha  -30.20403 Ha -1.92915 (7.09×10⁻² ) R\n[ 17/200] 3.81×10⁻²  1.91×10⁻¹   -14.57934 Ha = -396.71832 eV  +15.54476 Ha  -30.12410 Ha -1.93789 (6.21×10⁻² ) R\n[ 18/200] 2.84×10⁻²  1.01×10⁻¹   -14.59405 Ha = -397.11857 eV  +15.49565 Ha  -30.08970 Ha -1.94182 (5.82×10⁻² ) R\n[ 19/200] 2.32×10⁻²  1.00×10⁻³   -14.60117 Ha = -397.31232 eV  +15.47621 Ha  -30.07738 Ha -1.94346 (5.65×10⁻² ) R\n[ 20/200] 2.09×10⁻²  1.00×10⁻³   -14.60414 Ha = -397.39320 eV  +15.47604 Ha  -30.08018 Ha -1.94366 (5.63×10⁻² ) R\n[ 21/200] 2.09×10⁻²  1.00×10⁻³   -14.60416 Ha = -397.39391 eV  +15.47588 Ha  -30.08004 Ha -1.94367 (5.63×10⁻² ) R\n[ 22/200] 2.08×10⁻²  1.00×10⁻³   -14.60419 Ha = -397.39462 eV  +15.47572 Ha  -30.07991 Ha -1.94368 (5.63×10⁻² ) R\n[ 23/200] 2.08×10⁻²  1.00×10⁻³   -14.60422 Ha = -397.39534 eV  +15.47555 Ha  -30.07977 Ha -1.94370 (5.63×10⁻² ) R\n[ 24/200] 2.08×10⁻²  1.01×10⁻¹   -14.60424 Ha = -397.39605 eV  +15.47539 Ha  -30.07963 Ha -1.94371 (5.63×10⁻² ) R\n[ 25/200] 2.08×10⁻²  1.91×10⁻¹   -14.60427 Ha = -397.39676 eV  +15.45898 Ha  -30.06325 Ha -1.94471 (5.53×10⁻² ) R\n[ 26/200] 1.87×10⁻²  2.72×10⁻¹   -14.60689 Ha = -397.46809 eV  +15.43104 Ha  -30.03793 Ha -1.94659 (5.34×10⁻² ) R\n[ 27/200] 1.52×10⁻²  3.45×10⁻¹   -14.61128 Ha = -397.58758 eV  +15.39927 Ha  -30.01055 Ha -1.94883 (5.12×10⁻² ) R\n[ 28/200] 1.11×10⁻²  4.10×10⁻¹   -14.61624 Ha = -397.72243 eV  +15.37090 Ha  -29.98714 Ha -1.95090 (4.91×10⁻² ) R\n[ 29/200] 7.32×10⁻³  4.69×10⁻¹   -14.62071 Ha = -397.84423 eV  +15.35013 Ha  -29.97084 Ha -1.95248 (4.75×10⁻² ) R\n[ 30/200] 4.33×10⁻³  5.22×10⁻¹   -14.62414 Ha = -397.93747 eV  +15.33755 Ha  -29.96169 Ha -1.95349 (4.65×10⁻² )\n[ 31/200] 2.30×10⁻³  5.70×10⁻¹   -14.62642 Ha = -397.99953 eV  +15.33134 Ha  -29.95776 Ha -1.95402 (4.60×10⁻² )\n[ 32/200] 1.10×10⁻³  6.13×10⁻¹   -14.62776 Ha = -398.03592 eV  +15.32898 Ha  -29.95674 Ha -1.95426 (4.57×10⁻² )\n[ 33/200] 4.74×10⁻⁴  6.52×10⁻¹   -14.62845 Ha = -398.05482 eV  +15.32839 Ha  -29.95684 Ha -1.95434 (4.57×10⁻² )\n\nFinished in 0.9416050910949707 seconds\n┌───────┬────────────────────────┬────────────────────────┬───────────────────────┐\n│ i – j │                  ⟨i|j⟩ │                ⟨i|𝔣|j⟩ │               ⟨j|𝔣|i⟩ │\n├───────┼────────────────────────┼────────────────────────┼───────────────────────┤\n│ 2 – 2 │     0.9999961059152673 │     -4.766687758807457 │    -4.766687758807457 │\n│ 2 – 4 │ -1.4285951450204454e-8 │  0.0002211661797713788 │ 0.0002211661797724507 │\n│ 4 – 4 │     0.9997403317297171 │    -0.3181852936952018 │   -0.3181852936952018 │\n│ 1 – 1 │     0.9999961059152672 │     -4.766687758805878 │    -4.766687758805878 │\n│ 1 – 3 │ -1.4285197072494597e-8 │ 0.00022116616548698294 │ 0.0002211661654858277 │\n│ 3 – 3 │     0.9997403317297165 │    -0.3181852936952392 │   -0.3181852936952392 │\n└───────┴────────────────────────┴────────────────────────┴───────────────────────┘\nIteration   |g|        Energy                         ⟨T̂⟩           ⟨V̂⟩           ⟨V̂⟩/⟨T̂⟩ ⟨V̂⟩/⟨T̂⟩ + 2    Flags\n[   1/1000] 6.65×10⁰    -14.62898 Ha = -398.06906 eV  +15.32839 Ha  -29.95737 Ha -1.95437 (4.56×10⁻² )\n[   2/1000] 1.12×10⁻³   -14.62898 Ha = -398.06906 eV  +15.32927 Ha  -29.95825 Ha -1.95432 (4.57×10⁻² )\n[   3/1000] 1.14×10⁻³   -14.62898 Ha = -398.06906 eV  +15.32928 Ha  -29.95826 Ha -1.95432 (4.57×10⁻² )\n[   4/1000] 1.00×10⁻³   -14.62898 Ha = -398.06906 eV  +15.32917 Ha  -29.95814 Ha -1.95432 (4.57×10⁻² )\n[   5/1000] 8.28×10⁻⁴   -14.62898 Ha = -398.06906 eV  +15.32914 Ha  -29.95811 Ha -1.95432 (4.57×10⁻² )\n[   6/1000] 7.03×10⁻⁴   -14.62898 Ha = -398.06906 eV  +15.32906 Ha  -29.95803 Ha -1.95433 (4.57×10⁻² )\n[   7/1000] 6.47×10⁻⁴   -14.62898 Ha = -398.06906 eV  +15.32898 Ha  -29.95795 Ha -1.95433 (4.57×10⁻² )\n[   8/1000] 6.23×10⁻⁴   -14.62898 Ha = -398.06906 eV  +15.32890 Ha  -29.95788 Ha -1.95434 (4.57×10⁻² )\n[   9/1000] 6.02×10⁻⁴   -14.62898 Ha = -398.06906 eV  +15.32884 Ha  -29.95781 Ha -1.95434 (4.57×10⁻² )\n[  10/1000] 5.81×10⁻⁴   -14.62898 Ha = -398.06906 eV  +15.32878 Ha  -29.95776 Ha -1.95435 (4.57×10⁻² )\n⁞\n[ 104/1000] 1.14×10⁻⁶   -14.62898 Ha = -398.06906 eV  +15.32847 Ha  -29.95745 Ha -1.95437 (4.56×10⁻² )\n[ 105/1000] 1.05×10⁻⁶   -14.62898 Ha = -398.06906 eV  +15.32847 Ha  -29.95745 Ha -1.95437 (4.56×10⁻² )\n  1.692566 seconds (1.99 M allocations: 140.474 MiB, 16.79% gc time)\n * Status: success\n\n * Candidate solution\n    Minimizer: [6.00e-01, 1.23e+00, 1.39e+00,  ...]\n    Minimum:   -1.462898e+01\n\n * Found with\n    Algorithm:     BFGS\n    Initial Point: [6.00e-01, 1.23e+00, 1.39e+00,  ...]\n\n * Convergence measures\n    |x - x'|               = 1.85e-08 ≰ 0.0e+00\n    |x - x'|/|x'|          = 1.33e-08 ≰ 0.0e+00\n    |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00\n    |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00\n    |g(x)|                 = 1.05e-06 ≰ 1.0e-08\n\n * Work counters\n    Seconds run:   1  (vs limit Inf)\n    Iterations:    104\n    f(x) calls:    213\n    ∇f(x) calls:   214\n\nFinished in 2.8848788738250732 seconds\n┌───────┬─────────────────────────┬────────────────────────┬────────────────────────┐\n│ i – j │                   ⟨i|j⟩ │                ⟨i|𝔣|j⟩ │                ⟨j|𝔣|i⟩ │\n├───────┼─────────────────────────┼────────────────────────┼────────────────────────┤\n│ 2 – 2 │      0.9999999999999997 │     -4.766576166630178 │     -4.766576166630178 │\n│ 2 – 4 │ -1.9455136301643975e-17 │  0.0002081264173954475 │ 0.00020812641739532037 │\n│ 4 – 4 │      0.9999999999999997 │    -0.3181123088680883 │    -0.3181123088680883 │\n│ 1 – 1 │      0.9999999999999994 │     -4.766576166630179 │     -4.766576166630179 │\n│ 1 – 3 │   2.076818550021598e-18 │ 0.00020812640451178777 │  0.0002081264045114301 │\n│ 3 – 3 │                     1.0 │   -0.31811230886808745 │   -0.31811230886808745 │\n└───────┴─────────────────────────┴────────────────────────┴────────────────────────┘\nFock operator with\n- quantum system: Atom{Float64}(R=Radial finite differences basis {Float64} on 0.0..15.15 with 151 points spaced by ρ = 0.1; Z = 4 [beryllium]; 4 e⁻ ⇒ Q = 0) with 1 Configuration{SpinOrbital{Orbital{Int64},Tuple{Int64,HalfIntegers.Half{Int64}}}}: 1s₀α 1s₀β 2s₀α 2s₀β\n- SCF equations:\n  - Hartree–Fock equation: E|1s₀α⟩ = OrbitalEquation(1s₀α):\n  [1, 1]  =  + 1ĥ₀|1s₀α⟩ + 1r⁻¹×Y⁰(1s₀β,1s₀β)|1s₀α⟩ … - 1r⁻¹×Y⁰(2s₀α,1s₀α)|2s₀α⟩ + 1r⁻¹×Y⁰(2s₀β,2s₀β)|1s₀α⟩\n\n⟨1s₀α| 𝓗 |1s₀α⟩ = -4.766576166630178 Ha = -129.70330407017377 eV\n\n  - Hartree–Fock equation: E|1s₀β⟩ = OrbitalEquation(1s₀β):\n  [1, 1]  =  + 1ĥ₀|1s₀β⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|1s₀β⟩ … + 1r⁻¹×Y⁰(2s₀β,2s₀β)|1s₀β⟩ - 1r⁻¹×Y⁰(2s₀β,1s₀β)|2s₀β⟩\n\n⟨1s₀β| 𝓗 |1s₀β⟩ = -4.766576166630178 Ha = -129.70330407017377 eV\n\n  - Hartree–Fock equation: E|2s₀α⟩ = OrbitalEquation(2s₀α):\n  [1, 1]  =  + 1ĥ₀|2s₀α⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|2s₀α⟩ … + 1r⁻¹×Y⁰(1s₀β,1s₀β)|2s₀α⟩ + 1r⁻¹×Y⁰(2s₀β,2s₀β)|2s₀α⟩\n\n⟨2s₀α| 𝓗 |2s₀α⟩ = -0.31811230886808733 Ha = -8.656154036609523 eV\n\n  - Hartree–Fock equation: E|2s₀β⟩ = OrbitalEquation(2s₀β):\n  [1, 1]  =  + 1ĥ₀|2s₀β⟩ + 1r⁻¹×Y⁰(1s₀α,1s₀α)|2s₀β⟩ … - 1r⁻¹×Y⁰(1s₀β,2s₀β)|1s₀β⟩ + 1r⁻¹×Y⁰(2s₀α,2s₀α)|2s₀β⟩\n\n⟨2s₀β| 𝓗 |2s₀β⟩ = -0.3181123088680882 Ha = -8.656154036609548 eV","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Beryllium FEDVR orbitals)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Comparing with the FEDVR calculation, the total and orbital energies are slightly worse, but the calculation is much faster!","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Energy Hartree–Fock limit FEDVR FD\nTotal -14.573023 Ha -14.57302 Ha -14.62898 Ha\n1s -4.7326698 Ha -4.7326681 Ha -4.7665762 Ha\n2s -0.3092695 Ha -0.3092689 Ha -0.3181123 Ha","category":"page"},{"location":"equation_systems/#Equation-systems","page":"Equation systems","title":"Equation systems","text":"","category":"section"},{"location":"equation_systems/","page":"Equation systems","title":"Equation systems","text":"CurrentModule = AtomicStructure\nDocTestSetup = quote\n    using AtomicStructure\nend","category":"page"},{"location":"equation_systems/","page":"Equation systems","title":"Equation systems","text":"AtomicEquations\nSCF.update!(equations::AtomicEquations; kwargs...)\nSCF.energy_matrix!(H::HM, hfeqs::AtomicEquations, which::Symbol=:total) where {HM<:AbstractMatrix}\nfind_symmetries\ngenerate_atomic_orbital_equations\nBase.diff","category":"page"},{"location":"equation_systems/#AtomicStructure.AtomicEquations","page":"Equation systems","title":"AtomicStructure.AtomicEquations","text":"AtomicEquations(atom, equations, integrals)\n\nStructure representing the (e.g. Hartree–Fock) equations for atom, along with all integrals that are shared between the equations.\n\n\n\n\n\n","category":"type"},{"location":"equation_systems/#AtomicStructure.SCF.update!-Tuple{AtomicStructure.AtomicEquations}","page":"Equation systems","title":"AtomicStructure.SCF.update!","text":"SCF.update!(p::DirectPotential)\n\nUpdate the direct potential p by solving the Poisson problem with the current values of the orbitals forming the mutual density.\n\n\n\n\n\nSCF.update!(p::DirectPotential, atom::Atom)\n\nUpdate the direct potential p by solving the Poisson problem with the current values of the orbitals of atom forming the mutual density.\n\n\n\n\n\nupdate!(equations::AtomicEquations[, atom::Atom])\n\nRecompute all integrals using the current values for the radial orbitals (optionally specifying which atom from which the orbitals are taken).\n\n\n\n\n\nupdate!(eqs; kwargs...)\n\nUpdate the equation system eqs, for the current iteration. To be overloaded by the user.\n\n\n\n\n\n","category":"method"},{"location":"equation_systems/#AtomicStructure.SCF.energy_matrix!-Union{Tuple{HM}, Tuple{HM, AtomicStructure.AtomicEquations}, Tuple{HM, AtomicStructure.AtomicEquations, Symbol}} where HM<:(AbstractMatrix)","page":"Equation systems","title":"AtomicStructure.SCF.energy_matrix!","text":"energy_matrix!(H, hfeqs::AtomicEquations[, which=:energy])\n\nCompute the energy matrix by computing the energy observable and storing it in H. Requires that hfeqs has the :energy and :kinetic_energy Observables registered (this is the default).\n\n\n\n\n\n","category":"method"},{"location":"equation_systems/#AtomicStructure.find_symmetries","page":"Equation systems","title":"AtomicStructure.find_symmetries","text":"find_symmetries(orbitals)\n\nGroup all orbitals according to their symmetries, e.g. ℓ for Orbitals. This is used to determine which off-diagonal Lagrange multipliers are necessary to maintain orthogonality.\n\n\n\n\n\n","category":"function"},{"location":"equation_systems/#AtomicStructure.generate_atomic_orbital_equations","page":"Equation systems","title":"AtomicStructure.generate_atomic_orbital_equations","text":"generate_atomic_orbital_equations(atom::Atom, eqs::MCEquationSystem,\n                                  integrals, integral_map)\n\nFor each variationally derived orbital equation in eqs, generate the corresponding AtomicOrbitalEquation.\n\n\n\n\n\n","category":"function"},{"location":"equation_systems/#Base.diff","page":"Equation systems","title":"Base.diff","text":"diff(atom; H=atomic_hamiltonian(atom), overlaps=[], selector=outsidecoremodel, verbosity=0)\n\nDifferentiate the energy expression of the Hamiltonian H associated with the atom's configurations(s) with respect to the atomic orbitals to derive the Hartree–Fock equations for the orbitals.\n\nBy default, the Hamiltonian H=FieldFreeOneBodyHamiltonian()+CoulombInteraction().\n\nNon-orthogonality between orbitals can be specified by providing OrbitalOverlaps between these pairs. Only those electrons not modelled by atom.potential of each configuration are considered for generating the energy expression, this can be changed by choosing another value for selector.\n\n\n\n\n\ndiff(quantum_system[; kwargs...])\n\nVaries the the quantum_system with respect to all orbitals. Used to derive the multi-configurational Hartree–Fock equations. To be overloaded by the implementation of AbstractQuantumSystem.\n\n\n\n\n\n","category":"function"},{"location":"equation_systems/#Common-integrals","page":"Equation systems","title":"Common integrals","text":"","category":"section"},{"location":"equation_systems/","page":"Equation systems","title":"Equation systems","text":"When deriving the equations of motion from an energy expression, the same integral may appear many times in the equations for different orbitals, multiplied by different factors, etc. To minimize the reevaluation of integrals, AtomicEquations keeps track of all the common integrals, and they are recomputed exactly once, when SCF.update! is called. The routines below are used when setting up the equation system.","category":"page"},{"location":"equation_systems/","page":"Equation systems","title":"Equation systems","text":"pushterms!","category":"page"},{"location":"equation_systems/#AtomicStructure.pushterms!","page":"Equation systems","title":"AtomicStructure.pushterms!","text":"pushterms!(terms, operator, equation_terms,\n           integrals, integral_map, symbolic_integrals)\n\nFor each term in equation_terms, push a term, located at CI coordinates i,j, of the overall orbital Hamiltonian to terms, constructed from operator and a product of orbital integrals, multiplied by an overall factor given by expression and multipole expansions. integrals contain common OrbitalIntegrals and integral_map maps from symbolic_integrals to integrals.\n\n\n\n\n\n","category":"function"},{"location":"equation_systems/","page":"Equation systems","title":"Equation systems","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"observables/#Observables","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"observables/","page":"Observables","title":"Observables","text":"CurrentModule = AtomicStructure\nDocTestSetup = quote\n    using AtomicStructure\nend","category":"page"},{"location":"observables/","page":"Observables","title":"Observables","text":"Observable\nObservable(operator::QuantumOperator, atom::A, overlaps::Vector{<:OrbitalOverlap}, integrals::Vector{OrbitalIntegral}, integral_map::Dict{Any,Int}, symmetries::Dict, selector::Function; double_counted::Bool) where {T,A<:Atom{T}}\nobserve!","category":"page"},{"location":"observables/#AtomicStructure.Observable","page":"Observables","title":"AtomicStructure.Observable","text":"Observable\n\nRepresents a physical quantity that can be observed, which is calculated as the matrix element of an operator between two configurations. All physical observables are real.\n\n\n\n\n\n","category":"type"},{"location":"observables/#AtomicStructure.observe!","page":"Observables","title":"AtomicStructure.observe!","text":"observe!(A::M, o::Observable)\n\nCompute the observable o between all configurations and store the results as matrix elements of A.\n\n\n\n\n\nobserve!(A::M, atom::Atom, o::Observable)\n\nCompute the observable o between all configurations and store the results as matrix elements of A. The right-hand side vectors are taken from the equations, whereas the lefth-hand side vectors are taken from atom.\n\n\n\n\n\nobserve!(A::M, o::Observable, atom::Atom)\n\nCompute the observable o between all configurations, store the results as matrix elements of A, and finally contract with respect to the mixing coefficients of atom and return the result as a scalar. o is not update!d with respect to atom.\n\n\n\n\n\nobserve!(A::M, o::Observable, a::Atom, b::Atom)\n\nCompute the observable o between all configurations, store the results as matrix elements of A, and finally contract with respect to the mixing coefficients of atoms a & b and return the result as a scalar, which corresponds to a transition between the states of the respective atoms. o will be update!d with respect to b.\n\n\n\n\n\n","category":"function"},{"location":"observables/","page":"Observables","title":"Observables","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"orbital_equations/#Orbital-equations","page":"Orbital equations","title":"Orbital equations","text":"","category":"section"},{"location":"orbital_equations/","page":"Orbital equations","title":"Orbital equations","text":"CurrentModule = AtomicStructure\nDocTestSetup = quote\n    using AtomicStructure\nend","category":"page"},{"location":"orbital_equations/#Hamiltonian","page":"Orbital equations","title":"Hamiltonian","text":"","category":"section"},{"location":"orbital_equations/","page":"Orbital equations","title":"Orbital equations","text":"OrbitalHamiltonianTerm\ncoefficient\nOrbitalHamiltonian\nProjector\nprojectout!\nSCF.energy_matrix!(H::HM, hamiltonian::OrbitalHamiltonian{aO,bO,O,T}, ϕ::RadialOrbital{T}) where {HM<:AbstractMatrix,aO,bO,O,T}\nBase.filter(fun::Function, H::OrbitalHamiltonian)\nBase.copyto!(dest::M, hamiltonian::OrbitalHamiltonian) where {T,M<:AbstractMatrix{T}}\nBase.:(+)(h::OrbitalHamiltonian{O,T,B,OV,Proj}, λ::UniformScaling) where {O,T,B,OV,Proj}\nBase.:(-)(h::OrbitalHamiltonian, λ::UniformScaling)\nSCF.KrylovWrapper\nLinearAlgebra.mul!(y::V₁, A::KrylovWrapper{T,Hamiltonian}, x::V₂) where {V₁,V₂,T,B,Hamiltonian<:OrbitalHamiltonian}","category":"page"},{"location":"orbital_equations/#AtomicStructure.OrbitalHamiltonianTerm","page":"Orbital equations","title":"AtomicStructure.OrbitalHamiltonianTerm","text":"OrbitalHamiltonianTerm(i, j, coeff, A, integrals)\n\nRepresents a term in the orbital Hamiltonian arising from a variation of the energy expressions between configurations i and j in the multi-configurational expansion. coeff is the numeric coefficient, A is the operator acting on the orbital, and integrals is a vector of OrbitalIntegrals arising from the presence of non-orthogonal orbitals and whose values should be multiplied to form the overall coefficient.\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#AtomicStructure.coefficient","page":"Orbital equations","title":"AtomicStructure.coefficient","text":"coefficient(term::OrbitalHamiltonianTerm)\n\nReturn the multiplicative coefficient pertaining to term, excluding the conj(c_i)*c_j mixing coefficients, due to the configuration-interaction.\n\n\n\n\n\ncoefficient(term::OrbitalHamiltonianTerm, c::Vector)\n\nReturn the multiplicative coefficient pertaining to term, including the conj(c_i)*c_j mixing coefficients, due to the configuration-interaction.\n\n\n\n\n\n","category":"function"},{"location":"orbital_equations/#AtomicStructure.OrbitalHamiltonian","page":"Orbital equations","title":"AtomicStructure.OrbitalHamiltonian","text":"OrbitalHamiltonian(R, terms, mix_coeffs, projector, orbital)\n\nThe Hamiltonian for orbital is constructed from a radial basis R, a set of OrbitalHamiltonianTerm terms that describe the various interactions between orbitals, mix_coeffs which are the mixing coefficents for the multi-configurational expansion. The projector ensures orthogonality between orbital pairs which have Lagrange multipliers associated with them, by projecting out components of other orbitals every time the OrbitalHamiltonian action on orbital is computed.\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#AtomicStructure.Projector","page":"Orbital equations","title":"AtomicStructure.Projector","text":"Projector(ϕs, orbitals, S)\n\nRepresents the projector on the subspace spanned by the radial orbitals ϕs (corresponding to orbitals).\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#AtomicStructure.projectout!","page":"Orbital equations","title":"AtomicStructure.projectout!","text":"projectout!(y, projector)\n\nProject out all components of y parallel to the radial orbitals projector.ϕs.\n\n\n\n\n\n","category":"function"},{"location":"orbital_equations/#AtomicStructure.SCF.energy_matrix!-Union{Tuple{T}, Tuple{O}, Tuple{bO}, Tuple{aO}, Tuple{HM}, Tuple{HM, AtomicStructure.OrbitalHamiltonian{aO, bO, O, T}, LazyArrays.Applied{<:Any, typeof(*), <:Tuple{var\"#s128\", var\"#s127\"} where {var\"#s128\"<:(Union{B, var\"#s5\"} where var\"#s5\"<:(QuasiArrays.SubQuasiArray{<:Any, <:Any, <:B})), var\"#s127\"<:AbstractVector{T}}} where B<:ContinuumArrays.Basis}} where {HM<:(AbstractMatrix), aO, bO, O, T}","page":"Orbital equations","title":"AtomicStructure.SCF.energy_matrix!","text":"energy_matrix!(H, hamiltonian, ϕ)\n\nCompute the contribution of hamiltonian to the Hamiltonian matrix H by repeatedly acting on the associated radial orbital ϕ with the different multi-configurational OrbitalHamiltonianTerms of hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"orbital_equations/#Base.filter-Tuple{Function, AtomicStructure.OrbitalHamiltonian}","page":"Orbital equations","title":"Base.filter","text":"filter(fun::Function, H::OrbitalHamiltonian)\n\nFilter the OrbitalHamiltonianTerms of H according to the predicate fun.\n\n\n\n\n\n","category":"method"},{"location":"orbital_equations/#Base.copyto!-Union{Tuple{M}, Tuple{T}, Tuple{M, AtomicStructure.OrbitalHamiltonian}} where {T, M<:AbstractMatrix{T}}","page":"Orbital equations","title":"Base.copyto!","text":"copyto!(dest::AbstractMatix, hamiltonian::OrbitalHamiltonian)\n\nMaterialize the orbital hamiltonian into matrix form and store it in dest, using the current values of all other orbitals. This is only possible if the orbital hamiltonian does not contain any ExchangePotentials or SourceTerms (which are not diagonal in orbital space), since the former is non-local (and thus not representable as a matrix) and the latter is not a linear operator (but an affine one).\n\nTypical usage is to compute an easily factorizable matrix that can be used for preconditioning the solution of the full equation.\n\n\n\n\n\n","category":"method"},{"location":"orbital_equations/#Base.:+-Union{Tuple{Proj}, Tuple{OV}, Tuple{B}, Tuple{T}, Tuple{O}, Tuple{AtomicStructure.OrbitalHamiltonian{O, T, B, OV, Proj}, UniformScaling}} where {O, T, B, OV, Proj}","page":"Orbital equations","title":"Base.:+","text":"h::OrbitalHamiltonian + λ::UniformScaling\n\nShift the OrbitalHamiltonian h by λ.\n\n\n\n\n\n","category":"method"},{"location":"orbital_equations/#Base.:--Tuple{AtomicStructure.OrbitalHamiltonian, UniformScaling}","page":"Orbital equations","title":"Base.:-","text":"h::OrbitalHamiltonian - λ::UniformScaling\n\nShift the OrbitalHamiltonian h by -λ.\n\n\n\n\n\n","category":"method"},{"location":"orbital_equations/#AtomicStructure.SCF.KrylovWrapper","page":"Orbital equations","title":"AtomicStructure.SCF.KrylovWrapper","text":"KrylovWrapper(hamiltonian)\n\nProxy object used in the Krylov iterations, during orbital improvement. This is useful, since hamiltonian may be defined to act on objects such as vectors living in function spaces (as e.g. implemented using ContinuumArrays.jl), whereas the SCF iterations act on the coefficients directly.\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#Orbital-integrals-and-terms","page":"Orbital equations","title":"Orbital integrals and terms","text":"","category":"section"},{"location":"orbital_equations/","page":"Orbital equations","title":"Orbital equations","text":"OrbitalIntegral\nOrbitalOverlapIntegral\nSCF.update!(oo::OrbitalOverlapIntegral; kwargs...)\nHFPotential\nDirectPotential\nSCF.update!(p::DirectPotential{O,T,B,OV,RO,P}; kwargs...) where {O,T,B,OV,RO,P}\nLazyArrays.materialize!(ma::MulAdd{<:Any, <:Any, <:Any, T, <:DirectPotential, Source, Dest}) where {T,Source,Dest}\nExchangePotential\nLazyArrays.materialize!(ma::MulAdd{<:Any, <:Any, <:Any, T, <:ExchangePotential, Source, Dest}) where {T,Source,Dest}\nSourceTerm\nShiftTerm","category":"page"},{"location":"orbital_equations/#AtomicStructure.OrbitalIntegral","page":"Orbital equations","title":"AtomicStructure.OrbitalIntegral","text":"OrbitalIntegral{N}\n\nAbstract type for integrals of rank N of orbitals, whose values need to be recomputed every time the orbitals are updated. Rank 0 corresponds to a scalar value, rank 1 to a diagonal matrix, etc.\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#AtomicStructure.OrbitalOverlapIntegral","page":"Orbital equations","title":"AtomicStructure.OrbitalOverlapIntegral","text":"OrbitalOverlapIntegral(a, b, av, bv, value)\n\nRepresents the orbital overlap integral ⟨a|b⟩, for orbitals a and b, along with views of their radial orbitals av and bv and the current value of the integral.\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#AtomicStructure.SCF.update!-Tuple{AtomicStructure.OrbitalOverlapIntegral}","page":"Orbital equations","title":"AtomicStructure.SCF.update!","text":"SCF.update!(oo::OrbitalOverlapIntegral)\n\nUpdate the value of the integral oo.\n\n\n\n\n\n","category":"method"},{"location":"orbital_equations/#AtomicStructure.HFPotential","page":"Orbital equations","title":"AtomicStructure.HFPotential","text":"HFPotential(k, a, b, av, bv, V̂, poisson)\n\nRepresents the k:th multipole exansion of the Hartree–Fock potential formed by orbitals a and b (av and bv being views of their corresponding radial orbitals). V̂ is the resultant one-body potential formed, which can act on a third orbital and poisson computes the potential by solving Poisson's problem.\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#AtomicStructure.DirectPotential","page":"Orbital equations","title":"AtomicStructure.DirectPotential","text":"DirectPotential\n\nSpecial case of HFPotential for the direct interaction, in which case the potential formed from two orbitals can be precomputed before acting on a third orbital.\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#AtomicStructure.SCF.update!-Union{Tuple{AtomicStructure.HFPotential{:direct, O, T, B, OV, RO, P}}, Tuple{P}, Tuple{RO}, Tuple{OV}, Tuple{B}, Tuple{T}, Tuple{O}} where {O, T, B, OV, RO, P}","page":"Orbital equations","title":"AtomicStructure.SCF.update!","text":"SCF.update!(p::DirectPotential)\n\nUpdate the direct potential p by solving the Poisson problem with the current values of the orbitals forming the mutual density.\n\n\n\n\n\nupdate!(eqs; kwargs...)\n\nUpdate the equation system eqs, for the current iteration. To be overloaded by the user.\n\n\n\n\n\n","category":"method"},{"location":"orbital_equations/#Base.Broadcast.materialize!-Union{Tuple{ArrayLayouts.MulAdd{<:Any, <:Any, <:Any, T, <:AtomicStructure.HFPotential{:direct, aO, bO, T, OV} where {aO, bO, T, OV}, Source, Dest}}, Tuple{Dest}, Tuple{Source}, Tuple{T}} where {T, Source, Dest}","page":"Orbital equations","title":"Base.Broadcast.materialize!","text":"materialize!(::MulAdd{<:Any, <:Any, <:Any, T, <:AtomicOneBodyHamiltonian, Source, Dest})\n\nMaterialize the lazy multiplication–addition of the type y ← α*H*x + β*y where H is a AtomicOneBodyHamiltonian and x and y are RadialOrbitals.\n\n\n\n\n\n","category":"method"},{"location":"orbital_equations/#AtomicStructure.ExchangePotential","page":"Orbital equations","title":"AtomicStructure.ExchangePotential","text":"ExchangePotential\n\nSpecial case of HFPotential for the exchange interaction, in which case the potential is formed from the orbital acted upon, along with another orbital, and then applied to a third orbital. Thus this potential cannot be precomputed, but must be recomputed every time the operator is applied. This makes this potential expensive to handle and the number of times it is applied should be minimized, if possible.\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#Base.Broadcast.materialize!-Union{Tuple{ArrayLayouts.MulAdd{<:Any, <:Any, <:Any, T, <:AtomicStructure.HFPotential{:exchange, aO, bO, T, OV} where {aO, bO, T, OV}, Source, Dest}}, Tuple{Dest}, Tuple{Source}, Tuple{T}} where {T, Source, Dest}","page":"Orbital equations","title":"Base.Broadcast.materialize!","text":"materialize!(::MulAdd{<:Any, <:Any, <:Any, T, <:AtomicOneBodyHamiltonian, Source, Dest})\n\nMaterialize the lazy multiplication–addition of the type y ← α*H*x + β*y where H is a AtomicOneBodyHamiltonian and x and y are RadialOrbitals.\n\n\n\n\n\n","category":"method"},{"location":"orbital_equations/#AtomicStructure.SourceTerm","page":"Orbital equations","title":"AtomicStructure.SourceTerm","text":"SourceTerm(operator, source_orbital, ov)\n\nThe point of SourceTerm is to implement inhomogeneous terms that contribute to the equation for an orbital, and whose input is some other source_orbital. This kind of term appears in multi-configurational problems.\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#AtomicStructure.ShiftTerm","page":"Orbital equations","title":"AtomicStructure.ShiftTerm","text":"ShiftTerm(λ)\n\nThe point of ShiftTerm is to implement an overall energy shift of the Hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#Orbital-equations-2","page":"Orbital equations","title":"Orbital equations","text":"","category":"section"},{"location":"orbital_equations/","page":"Orbital equations","title":"Orbital equations","text":"AtomicOrbitalEquation\nSCF.energy(hfeq::AtomicOrbitalEquation, which::Symbol=:total)","category":"page"},{"location":"orbital_equations/#AtomicStructure.AtomicOrbitalEquation","page":"Orbital equations","title":"AtomicStructure.AtomicOrbitalEquation","text":"AtomicOrbitalEquation(atom, equation, orbital, ϕ, hamiltonian)\n\nGoverns the evolution of an atomic orbital belonging to an atom. equation is the symbolic expression, from which hamiltonian is constructed. ϕ is the QuasiVector representing the radial orbital.\n\n\n\n\n\n","category":"type"},{"location":"orbital_equations/#AtomicStructure.SCF.energy","page":"Orbital equations","title":"AtomicStructure.SCF.energy","text":"SCF.energy(hfeq::AtomicOrbitalEquation[, which=:total])\n\nCompute the orbital energy for the orbital governed by hfeq. Optionally select which contribution is computed (:total, :onebody, :direct, or :exchange).\n\n\n\n\n\n","category":"function"},{"location":"orbital_equations/","page":"Orbital equations","title":"Orbital equations","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"hydrogenic/#Hydrogenic-initialization","page":"Hydrogenic initialization","title":"Hydrogenic initialization","text":"","category":"section"},{"location":"hydrogenic/","page":"Hydrogenic initialization","title":"Hydrogenic initialization","text":"There are two modes of hydrogenic initialization implemented, plain hydrogenics, where all orbitals are initialized to as eigenorbitals of the bare charge Z, and screened hydrogenics, where each orbital i is initialized as the eigenorbital of an efficient charge Z-sigma_i, where sigma_i to some extent accounts for the screening of orbital i due to all the other electrons in the configuration.","category":"page"},{"location":"hydrogenic/","page":"Hydrogenic initialization","title":"Hydrogenic initialization","text":"CurrentModule = AtomicStructure\nDocTestSetup = quote\n    using AtomicStructure\n    using AtomicLevels\nend","category":"page"},{"location":"hydrogenic/#Plain-hydrogenics","page":"Hydrogenic initialization","title":"Plain hydrogenics","text":"","category":"section"},{"location":"hydrogenic/","page":"Hydrogenic initialization","title":"Hydrogenic initialization","text":"hydrogenic!","category":"page"},{"location":"hydrogenic/#AtomicStructure.hydrogenic!","page":"Hydrogenic initialization","title":"AtomicStructure.hydrogenic!","text":"hydrogenic!(atom[; find_lowest=false, find_lowest_ℓmax=Inf, kwargs...])\n\nInitialize the radial orbitals of atom to their unscreened hydrogenic values. This is done via simple diagonalization of the one-body Hamiltonian for each angular symmetry. If find_lowest is true, only the orbital(s) with the lowest energy is kept (out of those with ℓ≤find_lowest_ℓmax). The kwargs are passed on to diagonalize_one_body and can be used to influence how the diagonalization is performed.\n\n\n\n\n\n","category":"function"},{"location":"hydrogenic/#Screened-hydrogenics","page":"Hydrogenic initialization","title":"Screened hydrogenics","text":"","category":"section"},{"location":"hydrogenic/","page":"Hydrogenic initialization","title":"Hydrogenic initialization","text":"screened_hydrogenic!\nAtomicStructure.screening","category":"page"},{"location":"hydrogenic/#AtomicStructure.screened_hydrogenic!","page":"Hydrogenic initialization","title":"AtomicStructure.screened_hydrogenic!","text":"screened_hydrogenic!(atom[; kwargs...])\n\nInitialize the radial orbitals of atom to their screened hydrogenic values. This is done via simple diagonalization of the one-body Hamiltonian for each orbital with screening computed from all the other orbitals of the first configuration of atom. The kwargs are passed on to diagonalize_one_body and can be used to influence how the diagonalization is performed.\n\n\n\n\n\n","category":"function"},{"location":"hydrogenic/#AtomicStructure.screening","page":"Hydrogenic initialization","title":"AtomicStructure.screening","text":"screening(i, j)\n\nCompute the amount of screening of orbital i due to orbital j, according to the formula\n\nsigma_ij = left\n1 + left\nfrac3n_j^2 - ell_j(ell_j+1)3n_i^2 - ell_i(ell_i+1)\nright^2\nright^-32\n\ntaken from Eq. (10) of\n\nBessis, N., & Bessis, G. (1981). Analytic Atomic Shielding\nParameters. The Journal of Chemical Physics, 74(6),\n3628–3630. http://dx.doi.org/10.1063/1.441475\n\n\n\n\n\nscreening(i, c)\n\nCompute the screening of orbital i due to all other orbitals of configuration c:\n\nsigma_i = sum_j (w_j-delta_ij)sigma_ij\n\nwhere w_j is the occupancy of orbital j.\n\nExamples\n\njulia> AtomicStructure.screening(o\"1s\", c\"1s2 2s2\")\n0.3820869935387247\n\nThe 1s orbital is only slightly screened by the other 1s electron and the 2 2s electrons, whereas\n\njulia> AtomicStructure.screening(o\"2s\", c\"1s2 2s2\")\n2.179703979102134\n\nshows that the 2s electron is screened by both the 1s electrons and a little bit of the the other 2s electron.\n\n\n\n\n\n","category":"function"},{"location":"hydrogenic/","page":"Hydrogenic initialization","title":"Hydrogenic initialization","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"},{"location":"#AtomicStructure.jl","page":"Home","title":"AtomicStructure.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AtomicStructure.jl","category":"page"},{"location":"#A-note-on-usage","page":"Home","title":"A note on usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AtomicStructure.jl (and the whole JuliaAtoms cluster of libraries) is research grade software. This means, that although we try our best to ensure that the individual components behave as they should, and we do have a fair amount of complete calculations that we compare against values from the literature, we give no guarantees. Furthermore, AtomicStructure.jl is not an expert system, in that if the calculation does not converge, it will not try another route (such as e.g. ATSP or Grasp would); it also does not adapt the grid to the problem, this has to be set by the user before the calculation starts.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some things to check:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Is the grid large enough? Too small grids will force all eigenvalues to increase.\nIs the grid spacing small enough? Too coarse grids will not be able to resolve the finer details of the orbitals, which may or may not be a problem, depending on your use-case (i.e. the energies may be good enough, but matrix elements between orbitals not, etc).\nIf it seems that the optimizer cannot converge to the minimum, but instead just \"cycles\" a few energies, it could be worthwhile to try another line-search algorithm, e.g. More–Thuente instead of the default Hager–Zhang.\nTry with another basis set, increase or decrease polynomial order if using B-splines or FE-DVR, try with different knot-sets or placement of finite-elements.\nFor point-charge nuclei, there is a singularity at the origin (for ell=0) which needs to be accounted for (in terms of fulfilling the boundary conditions). For the finite-differences, CompactBases.jl provides one-point fixes that approximately satisfy the boundary conditions, for B-splines one can place the intervals densely close to the origin, for FE-DVR one can increase the polynomial order of the first element.","category":"page"},{"location":"one_body/#One-body-Hamiltonians","page":"One-body Hamiltonians","title":"One-body Hamiltonians","text":"","category":"section"},{"location":"one_body/","page":"One-body Hamiltonians","title":"One-body Hamiltonians","text":"CurrentModule = AtomicStructure\nDocTestSetup = quote\n    using AtomicStructure\nend","category":"page"},{"location":"one_body/","page":"One-body Hamiltonians","title":"One-body Hamiltonians","text":"The one-body Hamiltonian for electron i in an atom is given by","category":"page"},{"location":"one_body/","page":"One-body Hamiltonians","title":"One-body Hamiltonians","text":"beginequation\nhamiltonian_i defd\n-fracnabla_i^22 +\nV(vecr_i)\nendequation","category":"page"},{"location":"one_body/","page":"One-body Hamiltonians","title":"One-body Hamiltonians","text":"In spherical coordinates (and using reduced wavefunctions), the Laplacian transforms to","category":"page"},{"location":"one_body/","page":"One-body Hamiltonians","title":"One-body Hamiltonians","text":"beginequation\noperatorT_r_i = -fracpartial_r_i^22 + fracell(ell+1)2r_i^2\nendequation","category":"page"},{"location":"one_body/","page":"One-body Hamiltonians","title":"One-body Hamiltonians","text":"where the second term, called the centrifugal potential, although originating from the Laplacian, is usually treated together with the nuclear potential V(r_i).","category":"page"},{"location":"one_body/","page":"One-body Hamiltonians","title":"One-body Hamiltonians","text":"one_body_hamiltonian\nKineticEnergyHamiltonian\nPotentialEnergyHamiltonian\nAtomicOneBodyHamiltonian\nLazyArrays.materialize!(ma::MulAdd{<:Any, <:Any, <:Any, T, <:AtomicOneBodyHamiltonian, Source, Dest}) where {T,Source,Dest}","category":"page"},{"location":"one_body/#AtomicStructure.one_body_hamiltonian","page":"One-body Hamiltonians","title":"AtomicStructure.one_body_hamiltonian","text":"one_body_hamiltonian(::Type{Tuple}, atom, orb)\n\nReturn the kinetic and one-body potential energy operators (as a tuple) for the orbital orb of atom.\n\n\n\n\n\none_body_hamiltonian(::Type{Tuple}, atom, orb)\n\nReturn the one-body energy operator for the orbital orb of atom.\n\n\n\n\n\n","category":"function"},{"location":"one_body/#AtomicStructure.KineticEnergyHamiltonian","page":"One-body Hamiltonians","title":"AtomicStructure.KineticEnergyHamiltonian","text":"KineticEnergyHamiltonian\n\nThe kinetic energy part of the one-body Hamiltonian, ubcluding the centrifugal potential. It is diagonal in spin, i.e. it does not couple orbitals of opposite spin.\n\n\n\n\n\n","category":"type"},{"location":"one_body/#AtomicStructure.PotentialEnergyHamiltonian","page":"One-body Hamiltonians","title":"AtomicStructure.PotentialEnergyHamiltonian","text":"PotentialEnergyHamiltonian\n\nThe potential energy part of the one-body Hamiltonian. It is diagonal in spin, i.e. it does not couple orbitals of opposite spin.\n\n\n\n\n\n","category":"type"},{"location":"one_body/#AtomicStructure.AtomicOneBodyHamiltonian","page":"One-body Hamiltonians","title":"AtomicStructure.AtomicOneBodyHamiltonian","text":"AtomicOneBodyHamiltonian(op, orbital)\n\nStructure holding a one-body energy operator op acting on its associated orbital.\n\n\n\n\n\n","category":"type"},{"location":"one_body/#Base.Broadcast.materialize!-Union{Tuple{ArrayLayouts.MulAdd{<:Any, <:Any, <:Any, T, <:AtomicStructure.AtomicOneBodyHamiltonian, Source, Dest}}, Tuple{Dest}, Tuple{Source}, Tuple{T}} where {T, Source, Dest}","page":"One-body Hamiltonians","title":"Base.Broadcast.materialize!","text":"materialize!(::MulAdd{<:Any, <:Any, <:Any, T, <:AtomicOneBodyHamiltonian, Source, Dest})\n\nMaterialize the lazy multiplication–addition of the type y ← α*H*x + β*y where H is a AtomicOneBodyHamiltonian and x and y are RadialOrbitals.\n\n\n\n\n\n","category":"method"},{"location":"one_body/#Diagonalization-of-one-body-Hamiltonians","page":"One-body Hamiltonians","title":"Diagonalization of one-body Hamiltonians","text":"","category":"section"},{"location":"one_body/","page":"One-body Hamiltonians","title":"One-body Hamiltonians","text":"diagonalize_one_body","category":"page"},{"location":"one_body/#AtomicStructure.diagonalize_one_body","page":"One-body Hamiltonians","title":"AtomicStructure.diagonalize_one_body","text":"diagonalize_one_body(H, nev; method=:arnoldi_shift_invert, tol=1e-10, σ=-1)\n\nDiagonalize the one-body Hamiltonian H and find the nev lowest eigenpairs, using the specified diagonalization method; valid choices are\n\n:arnoldi which performs the standard Krylov iteration looking for the eigenvalues with smallest real values,\n:arnoldi_shift_invert which performs the Krylov iteration but with the shifted and inverted matrix (H - I*σ)⁻¹ looking for the eigenvalues with largest real values,\n:eigen which uses Julia's built-in eigensolver.\n\ntol sets the Krylov tolerance.\n\n\n\n\n\n","category":"function"},{"location":"one_body/","page":"One-body Hamiltonians","title":"One-body Hamiltonians","text":"CurrentModule = nothing\nDocTestSetup = nothing","category":"page"}]
}
