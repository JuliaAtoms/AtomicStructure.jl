<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Orbital equations · Atoms</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script src="../assets/latex.js"></script></head><body><nav class="toc"><h1>Atoms</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">Theory</span><ul><li><a class="toctext" href="../density_matrices/">Density matrices</a></li></ul></li><li><span class="toctext">Implementation</span><ul><li><a class="toctext" href="../radial_orbitals/">Radial orbitals</a></li><li><a class="toctext" href="../atom_types/">Atom types</a></li><li><a class="toctext" href="../one_body/">One-body Hamiltonians</a></li><li><a class="toctext" href="../hydrogenic/">Hydrogenic initialization</a></li><li class="current"><a class="toctext" href>Orbital equations</a><ul class="internal"><li><a class="toctext" href="#Hamiltonian-1">Hamiltonian</a></li><li><a class="toctext" href="#Orbital-integrals-and-terms-1">Orbital integrals and terms</a></li><li><a class="toctext" href="#Orbital-equations-2">Orbital equations</a></li></ul></li><li><a class="toctext" href="../equation_systems/">Equation systems</a></li><li><a class="toctext" href="../observables/">Observables</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Implementation</li><li><a href>Orbital equations</a></li></ul><a class="edit-page" href="https://github.com/JuliaAtoms/Atoms.jl/blob/master/docs/src/orbital_equations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Orbital equations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Orbital-equations-1" href="#Orbital-equations-1">Orbital equations</a></h1><h2><a class="nav-anchor" id="Hamiltonian-1" href="#Hamiltonian-1">Hamiltonian</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.OrbitalHamiltonianTerm" href="#Atoms.OrbitalHamiltonianTerm"><code>Atoms.OrbitalHamiltonianTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">OrbitalHamiltonianTerm(i, j, coeff, A, integrals)</code></pre><p>Represents a term in the orbital Hamiltonian arising from a variation of the energy expressions between configurations <code>i</code> and <code>j</code> in the multi-configurational expansion. <code>coeff</code> is the numeric coefficient, <code>A</code> is the operator acting on the orbital, and <code>integrals</code> is a vector of <a href="#Atoms.OrbitalIntegral"><code>OrbitalIntegral</code></a>s arising from the presence of non-orthogonal orbitals and whose values should be multiplied to form the overall coefficient.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L3-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.coefficient" href="#Atoms.coefficient"><code>Atoms.coefficient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coefficient(term::OrbitalHamiltonianTerm)</code></pre><p>Return the multiplicative coefficient pertaining to <code>term</code>, <em>excluding</em> the <code>conj(c_i)*c_j</code> mixing coefficients, due to the configuration-interaction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L21-L27">source</a><div><div><pre><code class="language-none">coefficient(term::OrbitalHamiltonianTerm, c::Vector)</code></pre><p>Return the multiplicative coefficient pertaining to <code>term</code>, <em>including</em> the <code>conj(c_i)*c_j</code> mixing coefficients, due to the configuration-interaction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L31-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.OrbitalHamiltonian" href="#Atoms.OrbitalHamiltonian"><code>Atoms.OrbitalHamiltonian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">OrbitalHamiltonian(R, terms, mix_coeffs, projector, orbital)</code></pre><p>The Hamiltonian for <code>orbital</code> is constructed from a radial basis <code>R</code>, a set of <a href="#Atoms.OrbitalHamiltonianTerm"><code>OrbitalHamiltonianTerm</code></a> <code>terms</code> that describe the various interactions between orbitals, <code>mix_coeffs</code> which are the mixing coefficents for the multi-configurational expansion. The <code>projector</code> ensures orthogonality between orbital pairs which have Lagrange multipliers associated with them, by projecting out components of other orbitals every time the <code>OrbitalHamiltonian</code> action on <code>orbital</code> is computed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L48-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.Projector" href="#Atoms.Projector"><code>Atoms.Projector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Projector(ϕs)</code></pre><p>Represents the projector <em>out of</em> the subspace spanned by the radial orbitals <code>ϕs</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/projectors.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.projectout!" href="#Atoms.projectout!"><code>Atoms.projectout!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">projectout!(y, projector)</code></pre><p>Project out all components of <code>y</code> parallel to the radial orbitals <code>projector.ϕs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/projectors.jl#L13-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.energy_matrix!-Union{Tuple{B}, Tuple{T}, Tuple{O}, Tuple{HM}, Tuple{HM,OrbitalHamiltonian{O,T,B,OV,Proj} where Proj where OV,MulQuasiArray{T,1,#s12} where #s12&lt;:(Mul{#s13,#s14} where #s14&lt;:(Tuple{#s15,#s16} where #s16&lt;:(AbstractArray{T,1} where T) where #s15&lt;:B) where #s13&lt;:Tuple)}} where B where T where O where HM&lt;:(AbstractArray{T,2} where T)" href="#SCF.energy_matrix!-Union{Tuple{B}, Tuple{T}, Tuple{O}, Tuple{HM}, Tuple{HM,OrbitalHamiltonian{O,T,B,OV,Proj} where Proj where OV,MulQuasiArray{T,1,#s12} where #s12&lt;:(Mul{#s13,#s14} where #s14&lt;:(Tuple{#s15,#s16} where #s16&lt;:(AbstractArray{T,1} where T) where #s15&lt;:B) where #s13&lt;:Tuple)}} where B where T where O where HM&lt;:(AbstractArray{T,2} where T)"><code>SCF.energy_matrix!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">energy_matrix!(H, hamiltonian, ϕ)</code></pre><p>Compute the contribution of <code>hamiltonian</code> to the Hamiltonian matrix <code>H</code> by repeatedly acting on the associated radial orbital <code>ϕ</code> with the different multi-configurational <a href="#Atoms.OrbitalHamiltonianTerm"><code>OrbitalHamiltonianTerm</code></a>s of <code>hamiltonian</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L76-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter-Tuple{Function,Atoms.OrbitalHamiltonian}" href="#Base.filter-Tuple{Function,Atoms.OrbitalHamiltonian}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">filter(fun::Function, H::OrbitalHamiltonian)</code></pre><p>Filter the <a href="#Atoms.OrbitalHamiltonianTerm"><code>OrbitalHamiltonianTerm</code></a>s of <code>H</code> according to the predicate <code>fun</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L94-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copyto!-Union{Tuple{M}, Tuple{T}, Tuple{M,OrbitalHamiltonian}} where M&lt;:AbstractArray{T,2} where T" href="#Base.copyto!-Union{Tuple{M}, Tuple{T}, Tuple{M,OrbitalHamiltonian}} where M&lt;:AbstractArray{T,2} where T"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">copyto!(dest::AbstractMatix, hamiltonian::OrbitalHamiltonian)</code></pre><p>Materialize the orbital <code>hamiltonian</code> into matrix form and store it in <code>dest</code>, using the current values of all other orbitals. This is only possible if the orbital <code>hamiltonian</code> does <em>not</em> contain any <a href="#Atoms.ExchangePotential"><code>ExchangePotential</code></a>s or <a href="#Atoms.SourceTerm"><code>SourceTerm</code></a>s, since the former is non-local (and thus not representable as a matrix) and the latter is not a linear operator (but an affine one).</p><p>Typical usage is to compute an easily factorizable matrix that can be used for preconditioning the solution of the full equation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L178-L190">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Union{Tuple{Proj}, Tuple{OV}, Tuple{B}, Tuple{T}, Tuple{O}, Tuple{OrbitalHamiltonian{O,T,B,OV,Proj},UniformScaling}} where Proj where OV where B where T where O" href="#Base.:+-Union{Tuple{Proj}, Tuple{OV}, Tuple{B}, Tuple{T}, Tuple{O}, Tuple{OrbitalHamiltonian{O,T,B,OV,Proj},UniformScaling}} where Proj where OV where B where T where O"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">h::OrbitalHamiltonian + λ::UniformScaling</code></pre><p>Shift the <a href="#Atoms.OrbitalHamiltonian"><code>OrbitalHamiltonian</code></a> <code>h</code> by <code>λ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L235-L239">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{Atoms.OrbitalHamiltonian,LinearAlgebra.UniformScaling}" href="#Base.:--Tuple{Atoms.OrbitalHamiltonian,LinearAlgebra.UniformScaling}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">h::OrbitalHamiltonian - λ::UniformScaling</code></pre><p>Shift the <a href="#Atoms.OrbitalHamiltonian"><code>OrbitalHamiltonian</code></a> <code>h</code> by <code>-λ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L248-L252">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.KrylovWrapper" href="#SCF.KrylovWrapper"><code>SCF.KrylovWrapper</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SCF.KrylovWrapper(hamiltonian::OrbitalHamiltonian)</code></pre><p>Construct a <code>KrylovWrapper</code> such that <code>hamiltonian</code>, that acts on function spaces, can be used in a Krylov solver, which works with linear algebra vector spaces.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L257-L263">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{Hamiltonian}, Tuple{B}, Tuple{T}, Tuple{V₂}, Tuple{V₁}, Tuple{V₁,KrylovWrapper{T,Hamiltonian},V₂}} where Hamiltonian&lt;:Atoms.OrbitalHamiltonian where B where T where V₂ where V₁" href="#LinearAlgebra.mul!-Union{Tuple{Hamiltonian}, Tuple{B}, Tuple{T}, Tuple{V₂}, Tuple{V₁}, Tuple{V₁,KrylovWrapper{T,Hamiltonian},V₂}} where Hamiltonian&lt;:Atoms.OrbitalHamiltonian where B where T where V₂ where V₁"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mul!(y, A::KrylovWrapper{T,&lt;:OrbitalHamiltonian}, x)</code></pre><p>Materialize the action of the <a href="#Atoms.OrbitalHamiltonian"><code>OrbitalHamiltonian</code></a> on the linear algebra vector <code>x</code> and store the result in <code>y</code>, by wrapping them both with the <code>QuasiMatrix</code> necessary to transform <code>x</code> and <code>y</code> to the function space of the Hamiltonian.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L270-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatrixFactorizations.preconditioner" href="#MatrixFactorizations.preconditioner"><code>MatrixFactorizations.preconditioner</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">MatrixFactorizations.preconditioner(hamiltonian::OrbitalHamiltonian)</code></pre><p>Return a factorization of the matrix corresponding to <code>hamiltonian</code>, where all terms arising from exchange and configuration interaction have been removes, since they cannot be represented by a matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_hamiltonian.jl#L283-L289">source</a></section><h2><a class="nav-anchor" id="Orbital-integrals-and-terms-1" href="#Orbital-integrals-and-terms-1">Orbital integrals and terms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.OrbitalIntegral" href="#Atoms.OrbitalIntegral"><code>Atoms.OrbitalIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">OrbitalIntegral{N}</code></pre><p>Abstract type for integrals of rank <code>N</code> of orbitals, whose values need to be recomputed every time the orbitals are updated. Rank 0 corresponds to a scalar value, rank 1 to a diagonal matrix, etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.OrbitalOverlapIntegral" href="#Atoms.OrbitalOverlapIntegral"><code>Atoms.OrbitalOverlapIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">OrbitalOverlapIntegral(a, b, av, bv, value)</code></pre><p>Represents the orbital overlap integral <code>⟨a|b⟩</code>, for orbitals <code>a</code> and <code>b</code>, along with <code>view</code>s of their radial orbitals <code>av</code> and <code>bv</code> and the current <code>value</code> of the integral.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L14-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.update!-Tuple{Atoms.OrbitalOverlapIntegral}" href="#SCF.update!-Tuple{Atoms.OrbitalOverlapIntegral}"><code>SCF.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">SCF.update!(oo::OrbitalOverlapIntegral)</code></pre><p>Update the value of the integral <code>oo</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L38-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.HFPotential" href="#Atoms.HFPotential"><code>Atoms.HFPotential</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HFPotential(k, a, b, av, bv, V̂, poisson)</code></pre><p>Represents the <code>k</code>:th multipole exansion of the Hartree–Fock potential formed by orbitals <code>a</code> and <code>b</code> (<code>av</code> and <code>bv</code> being <code>view</code>s of their corresponding radial orbitals). <code>V̂</code> is the resultant one-body potential formed, which can act on a third orbital and <code>poisson</code> computes the potential by solving Poisson&#39;s problem.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L53-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.DirectPotential" href="#Atoms.DirectPotential"><code>Atoms.DirectPotential</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DirectPotential</code></pre><p>Special case of <a href="#Atoms.HFPotential"><code>HFPotential</code></a> for the direct interaction, in which case the potential formed from two orbitals can be precomputed before acting on a third orbital.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L92-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.update!-Union{Tuple{HFPotential{:direct,O,T,B,OV,RO,P}}, Tuple{P}, Tuple{RO}, Tuple{OV}, Tuple{B}, Tuple{T}, Tuple{O}} where P where RO where OV where B where T where O" href="#SCF.update!-Union{Tuple{HFPotential{:direct,O,T,B,OV,RO,P}}, Tuple{P}, Tuple{RO}, Tuple{OV}, Tuple{B}, Tuple{T}, Tuple{O}} where P where RO where OV where B where T where O"><code>SCF.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">SCF.update!(p::DirectPotential)</code></pre><p>Update the direct potential <code>p</code> by solving the Poisson problem with the current values of the orbitals forming the mutual density.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L104-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.materialize!-Union{Tuple{MulAdd{#s2,#s1,#s3,T,#s4,Source,Dest} where #s4&lt;:(HFPotential{:direct,O,T,B,OV,RO,P} where P where RO where OV where B where T where O) where #s3 where #s1 where #s2}, Tuple{Dest}, Tuple{Source}, Tuple{T}} where Dest where Source where T" href="#Base.Broadcast.materialize!-Union{Tuple{MulAdd{#s2,#s1,#s3,T,#s4,Source,Dest} where #s4&lt;:(HFPotential{:direct,O,T,B,OV,RO,P} where P where RO where OV where B where T where O) where #s3 where #s1 where #s2}, Tuple{Dest}, Tuple{Source}, Tuple{T}} where Dest where Source where T"><code>Base.Broadcast.materialize!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">materialize!(::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:AtomicOneBodyHamiltonian, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*H*x + β*y</code> where <code>H</code> is a <a href="#Atoms.AtomicOneBodyHamiltonian"><code>AtomicOneBodyHamiltonian</code></a> and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/one_body.jl#L116-L122">source</a><div><div><pre><code class="language-none">materialize!(ma::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:DirectPotential, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*V̂*x + β*y</code> where <code>V̂</code> is a <a href="../orbital_equations/#Atoms.DirectPotential"><code>DirectPotential</code></a> (with a precomputed direct potential computed via <code>SCF.update!</code>) and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L115-L122">source</a><div><div><pre><code class="language-none">materialize!(ma::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:ExchangePotential, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*V̂*x + β*y</code> where <code>V̂</code> is a <a href="../orbital_equations/#Atoms.ExchangePotential"><code>ExchangePotential</code></a> (by solving the Poisson problem with <code>x</code> as one of the constituent source orbitals in the mutual density) and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L148-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.ExchangePotential" href="#Atoms.ExchangePotential"><code>Atoms.ExchangePotential</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ExchangePotential</code></pre><p>Special case of <a href="#Atoms.HFPotential"><code>HFPotential</code></a> for the exchange interaction, in which case the potential is formed from the orbital acted upon, along with another orbital, and then applied to a third orbital. Thus this potential <em>cannot</em> be precomputed, but must be recomputed every time the operator is applied. This makes this potential expensive to handle and the number of times it is applied should be minimized, if possible.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L129-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.materialize!-Union{Tuple{MulAdd{#s4,#s3,#s2,T,#s1,Source,Dest} where #s1&lt;:(HFPotential{:exchange,O,T,B,OV,RO,P} where P where RO where OV where B where T where O) where #s2 where #s3 where #s4}, Tuple{Dest}, Tuple{Source}, Tuple{T}} where Dest where Source where T" href="#Base.Broadcast.materialize!-Union{Tuple{MulAdd{#s4,#s3,#s2,T,#s1,Source,Dest} where #s1&lt;:(HFPotential{:exchange,O,T,B,OV,RO,P} where P where RO where OV where B where T where O) where #s2 where #s3 where #s4}, Tuple{Dest}, Tuple{Source}, Tuple{T}} where Dest where Source where T"><code>Base.Broadcast.materialize!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">materialize!(::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:AtomicOneBodyHamiltonian, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*H*x + β*y</code> where <code>H</code> is a <a href="#Atoms.AtomicOneBodyHamiltonian"><code>AtomicOneBodyHamiltonian</code></a> and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/one_body.jl#L116-L122">source</a><div><div><pre><code class="language-none">materialize!(ma::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:DirectPotential, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*V̂*x + β*y</code> where <code>V̂</code> is a <a href="../orbital_equations/#Atoms.DirectPotential"><code>DirectPotential</code></a> (with a precomputed direct potential computed via <code>SCF.update!</code>) and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L115-L122">source</a><div><div><pre><code class="language-none">materialize!(ma::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:ExchangePotential, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*V̂*x + β*y</code> where <code>V̂</code> is a <a href="../orbital_equations/#Atoms.ExchangePotential"><code>ExchangePotential</code></a> (by solving the Poisson problem with <code>x</code> as one of the constituent source orbitals in the mutual density) and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L148-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.SourceTerm" href="#Atoms.SourceTerm"><code>Atoms.SourceTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">SourceTerm(operator, source_orbital, ov)</code></pre><p>The point of <code>SourceTerm</code> is to implement inhomogeneous terms that contribute to the equation for an orbital, and whose input is some other <code>source_orbital</code>. This kind of term appears in multi-configurational problems.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L166-L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.ShiftTerm" href="#Atoms.ShiftTerm"><code>Atoms.ShiftTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ShiftTerm(λ)</code></pre><p>The point of <code>ShiftTerm</code> is to implement an overall energy shift of the Hamiltonian.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/89f86436bc45251a2e6f53eb000ef2d68ea5b7df/src/orbital_integrals.jl#L185-L190">source</a></section><h2><a class="nav-anchor" id="Orbital-equations-2" href="#Orbital-equations-2">Orbital equations</a></h2><pre><code class="language-none">AtomicOrbitalEquation
energy(hfeq::AtomicOrbitalEquation, term=:all)</code></pre><footer><hr/><a class="previous" href="../hydrogenic/"><span class="direction">Previous</span><span class="title">Hydrogenic initialization</span></a><a class="next" href="../equation_systems/"><span class="direction">Next</span><span class="title">Equation systems</span></a></footer></article></body></html>
