<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Orbital equations · Atoms</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script src="../assets/latex.js"></script></head><body><nav class="toc"><h1>Atoms</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li><span class="toctext">Theory</span><ul><li><a class="toctext" href="../density_matrices/">Density matrices</a></li></ul></li><li><span class="toctext">Implementation</span><ul><li><a class="toctext" href="../radial_orbitals/">Radial orbitals</a></li><li><a class="toctext" href="../atom_types/">Atom types</a></li><li><a class="toctext" href="../one_body/">One-body Hamiltonians</a></li><li><a class="toctext" href="../hydrogenic/">Hydrogenic initialization</a></li><li class="current"><a class="toctext" href>Orbital equations</a><ul class="internal"><li><a class="toctext" href="#Hamiltonian-1">Hamiltonian</a></li><li><a class="toctext" href="#Orbital-integrals-and-terms-1">Orbital integrals and terms</a></li><li><a class="toctext" href="#Orbital-equations-2">Orbital equations</a></li></ul></li><li><a class="toctext" href="../equation_systems/">Equation systems</a></li><li><a class="toctext" href="../observables/">Observables</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Implementation</li><li><a href>Orbital equations</a></li></ul><a class="edit-page" href="https://github.com/JuliaAtoms/Atoms.jl/blob/master/docs/src/orbital_equations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Orbital equations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Orbital-equations-1" href="#Orbital-equations-1">Orbital equations</a></h1><h2><a class="nav-anchor" id="Hamiltonian-1" href="#Hamiltonian-1">Hamiltonian</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.OrbitalHamiltonianTerm" href="#Atoms.OrbitalHamiltonianTerm"><code>Atoms.OrbitalHamiltonianTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OrbitalHamiltonianTerm(i, j, coeff, A, integrals)</code></pre><p>Represents a term in the orbital Hamiltonian arising from a variation of the energy expressions between configurations <code>i</code> and <code>j</code> in the multi-configurational expansion. <code>coeff</code> is the numeric coefficient, <code>A</code> is the operator acting on the orbital, and <code>integrals</code> is a vector of <a href="#Atoms.OrbitalIntegral"><code>OrbitalIntegral</code></a>s arising from the presence of non-orthogonal orbitals and whose values should be multiplied to form the overall coefficient.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L3-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.coefficient" href="#Atoms.coefficient"><code>Atoms.coefficient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">coefficient(term::OrbitalHamiltonianTerm)</code></pre><p>Return the multiplicative coefficient pertaining to <code>term</code>, <em>excluding</em> the <code>conj(c_i)*c_j</code> mixing coefficients, due to the configuration-interaction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L30-L36">source</a><div><div><pre><code class="language-none">coefficient(term::OrbitalHamiltonianTerm, c::Vector)</code></pre><p>Return the multiplicative coefficient pertaining to <code>term</code>, <em>including</em> the <code>conj(c_i)*c_j</code> mixing coefficients, due to the configuration-interaction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L42-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.OrbitalHamiltonian" href="#Atoms.OrbitalHamiltonian"><code>Atoms.OrbitalHamiltonian</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OrbitalHamiltonian(R, terms, mix_coeffs, projector, orbital)</code></pre><p>The Hamiltonian for <code>orbital</code> is constructed from a radial basis <code>R</code>, a set of <a href="#Atoms.OrbitalHamiltonianTerm"><code>OrbitalHamiltonianTerm</code></a> <code>terms</code> that describe the various interactions between orbitals, <code>mix_coeffs</code> which are the mixing coefficents for the multi-configurational expansion. The <code>projector</code> ensures orthogonality between orbital pairs which have Lagrange multipliers associated with them, by projecting out components of other orbitals every time the <code>OrbitalHamiltonian</code> action on <code>orbital</code> is computed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L64-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.Projector" href="#Atoms.Projector"><code>Atoms.Projector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Projector(ϕs, orbitals)</code></pre><p>Represents the projector on the subspace spanned by the radial orbitals <code>ϕs</code> (corresponding to <code>orbitals</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/projectors.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.projectout!" href="#Atoms.projectout!"><code>Atoms.projectout!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">projectout!(y, projector)</code></pre><p>Project out all components of <code>y</code> parallel to the radial orbitals <code>projector.ϕs</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/projectors.jl#L23-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.energy_matrix!-Union{Tuple{T}, Tuple{O}, Tuple{bO}, Tuple{aO}, Tuple{HM}, Tuple{HM,Atoms.OrbitalHamiltonian{aO,bO,O,T,Proj,RT} where RT where Proj,LazyArrays.Applied{#s18,typeof(*),#s17} where #s17&lt;:(Tuple{#s16,#s15} where #s15&lt;:AbstractArray{T,1} where #s16&lt;:(Union{LazyArrays.Applied{#s16,typeof(*),#s15} where #s15&lt;:(Tuple{#s12,#s13} where #s13&lt;:(BandedMatrices.BandedMatrix{#s12,#s13,RAXIS} where RAXIS where #s13&lt;:FillArrays.Ones where #s12&lt;:Int64)) where #s16 where #s12&lt;:B, B, #s16} where #s16&lt;:(QuasiArrays.ApplyQuasiArray{#s15,#s14,typeof(*),#s16} where #s16&lt;:(Tuple{#s13,#s131} where #s131&lt;:(BandedMatrices.BandedMatrix{#s12,#s13,RAXIS} where RAXIS where #s13&lt;:FillArrays.Ones where #s12&lt;:Int64)) where #s13&lt;:B where #s14 where #s15))) where #s18 where B&lt;:ContinuumArrays.Basis}} where T where O where bO where aO where HM&lt;:(AbstractArray{T,2} where T)" href="#SCF.energy_matrix!-Union{Tuple{T}, Tuple{O}, Tuple{bO}, Tuple{aO}, Tuple{HM}, Tuple{HM,Atoms.OrbitalHamiltonian{aO,bO,O,T,Proj,RT} where RT where Proj,LazyArrays.Applied{#s18,typeof(*),#s17} where #s17&lt;:(Tuple{#s16,#s15} where #s15&lt;:AbstractArray{T,1} where #s16&lt;:(Union{LazyArrays.Applied{#s16,typeof(*),#s15} where #s15&lt;:(Tuple{#s12,#s13} where #s13&lt;:(BandedMatrices.BandedMatrix{#s12,#s13,RAXIS} where RAXIS where #s13&lt;:FillArrays.Ones where #s12&lt;:Int64)) where #s16 where #s12&lt;:B, B, #s16} where #s16&lt;:(QuasiArrays.ApplyQuasiArray{#s15,#s14,typeof(*),#s16} where #s16&lt;:(Tuple{#s13,#s131} where #s131&lt;:(BandedMatrices.BandedMatrix{#s12,#s13,RAXIS} where RAXIS where #s13&lt;:FillArrays.Ones where #s12&lt;:Int64)) where #s13&lt;:B where #s14 where #s15))) where #s18 where B&lt;:ContinuumArrays.Basis}} where T where O where bO where aO where HM&lt;:(AbstractArray{T,2} where T)"><code>SCF.energy_matrix!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">energy_matrix!(H, hamiltonian, ϕ)</code></pre><p>Compute the contribution of <code>hamiltonian</code> to the Hamiltonian matrix <code>H</code> by repeatedly acting on the associated radial orbital <code>ϕ</code> with the different multi-configurational <a href="#Atoms.OrbitalHamiltonianTerm"><code>OrbitalHamiltonianTerm</code></a>s of <code>hamiltonian</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L98-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter-Tuple{Function,Atoms.OrbitalHamiltonian}" href="#Base.filter-Tuple{Function,Atoms.OrbitalHamiltonian}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">filter(fun::Function, H::OrbitalHamiltonian)</code></pre><p>Filter the <a href="#Atoms.OrbitalHamiltonianTerm"><code>OrbitalHamiltonianTerm</code></a>s of <code>H</code> according to the predicate <code>fun</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L116-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.copyto!-Union{Tuple{M}, Tuple{T}, Tuple{M,Atoms.OrbitalHamiltonian}} where M&lt;:AbstractArray{T,2} where T" href="#Base.copyto!-Union{Tuple{M}, Tuple{T}, Tuple{M,Atoms.OrbitalHamiltonian}} where M&lt;:AbstractArray{T,2} where T"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">copyto!(dest::AbstractMatix, hamiltonian::OrbitalHamiltonian)</code></pre><p>Materialize the orbital <code>hamiltonian</code> into matrix form and store it in <code>dest</code>, using the current values of all other orbitals. This is only possible if the orbital <code>hamiltonian</code> does <em>not</em> contain any <a href="#Atoms.ExchangePotential"><code>ExchangePotential</code></a>s or <a href="#Atoms.SourceTerm"><code>SourceTerm</code></a>s (which are not diagonal in orbital space), since the former is non-local (and thus not representable as a matrix) and the latter is not a linear operator (but an affine one).</p><p>Typical usage is to compute an easily factorizable matrix that can be used for preconditioning the solution of the full equation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L223-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:+-Union{Tuple{Proj}, Tuple{OV}, Tuple{B}, Tuple{T}, Tuple{O}, Tuple{Atoms.OrbitalHamiltonian{O,T,B,OV,Proj,RT} where RT,UniformScaling}} where Proj where OV where B where T where O" href="#Base.:+-Union{Tuple{Proj}, Tuple{OV}, Tuple{B}, Tuple{T}, Tuple{O}, Tuple{Atoms.OrbitalHamiltonian{O,T,B,OV,Proj,RT} where RT,UniformScaling}} where Proj where OV where B where T where O"><code>Base.:+</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">h::OrbitalHamiltonian + λ::UniformScaling</code></pre><p>Shift the <a href="#Atoms.OrbitalHamiltonian"><code>OrbitalHamiltonian</code></a> <code>h</code> by <code>λ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L275-L279">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:--Tuple{Atoms.OrbitalHamiltonian,UniformScaling}" href="#Base.:--Tuple{Atoms.OrbitalHamiltonian,UniformScaling}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">h::OrbitalHamiltonian - λ::UniformScaling</code></pre><p>Shift the <a href="#Atoms.OrbitalHamiltonian"><code>OrbitalHamiltonian</code></a> <code>h</code> by <code>-λ</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L289-L293">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.KrylovWrapper" href="#SCF.KrylovWrapper"><code>SCF.KrylovWrapper</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SCF.KrylovWrapper(hamiltonian::OrbitalHamiltonian)</code></pre><p>Construct a <code>KrylovWrapper</code> such that <code>hamiltonian</code>, that acts on function spaces, can be used in a Krylov solver, which works with linear algebra vector spaces.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L298-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{Hamiltonian}, Tuple{B}, Tuple{T}, Tuple{V₂}, Tuple{V₁}, Tuple{V₁,SCF.KrylovWrapper{T,Hamiltonian},V₂}} where Hamiltonian&lt;:Atoms.OrbitalHamiltonian where B where T where V₂ where V₁" href="#LinearAlgebra.mul!-Union{Tuple{Hamiltonian}, Tuple{B}, Tuple{T}, Tuple{V₂}, Tuple{V₁}, Tuple{V₁,SCF.KrylovWrapper{T,Hamiltonian},V₂}} where Hamiltonian&lt;:Atoms.OrbitalHamiltonian where B where T where V₂ where V₁"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mul!(y, A::KrylovWrapper{T,&lt;:OrbitalHamiltonian}, x)</code></pre><p>Materialize the action of the <a href="#Atoms.OrbitalHamiltonian"><code>OrbitalHamiltonian</code></a> on the linear algebra vector <code>x</code> and store the result in <code>y</code>, by wrapping them both with the <code>QuasiMatrix</code> necessary to transform <code>x</code> and <code>y</code> to the function space of the Hamiltonian.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L311-L318">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IterativeFactorizations.preconditioner" href="#IterativeFactorizations.preconditioner"><code>IterativeFactorizations.preconditioner</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">IterativeFactorizations.preconditioner(hamiltonian::OrbitalHamiltonian)</code></pre><p>Return a factorization of the matrix corresponding to <code>hamiltonian</code>, where all terms arising from exchange and configuration interaction have been removes, since they cannot be represented by a matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_hamiltonian.jl#L339-L345">source</a></section><h2><a class="nav-anchor" id="Orbital-integrals-and-terms-1" href="#Orbital-integrals-and-terms-1">Orbital integrals and terms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.OrbitalIntegral" href="#Atoms.OrbitalIntegral"><code>Atoms.OrbitalIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OrbitalIntegral{N}</code></pre><p>Abstract type for integrals of rank <code>N</code> of orbitals, whose values need to be recomputed every time the orbitals are updated. Rank 0 corresponds to a scalar value, rank 1 to a diagonal matrix, etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.OrbitalOverlapIntegral" href="#Atoms.OrbitalOverlapIntegral"><code>Atoms.OrbitalOverlapIntegral</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OrbitalOverlapIntegral(a, b, av, bv, value)</code></pre><p>Represents the orbital overlap integral <code>⟨a|b⟩</code>, for orbitals <code>a</code> and <code>b</code>, along with <code>view</code>s of their radial orbitals <code>av</code> and <code>bv</code> and the current <code>value</code> of the integral.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L23-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.update!-Tuple{Atoms.OrbitalOverlapIntegral}" href="#SCF.update!-Tuple{Atoms.OrbitalOverlapIntegral}"><code>SCF.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SCF.update!(oo::OrbitalOverlapIntegral)</code></pre><p>Update the value of the integral <code>oo</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L47-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.HFPotential" href="#Atoms.HFPotential"><code>Atoms.HFPotential</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HFPotential(k, a, b, av, bv, V̂, poisson)</code></pre><p>Represents the <code>k</code>:th multipole exansion of the Hartree–Fock potential formed by orbitals <code>a</code> and <code>b</code> (<code>av</code> and <code>bv</code> being <code>view</code>s of their corresponding radial orbitals). <code>V̂</code> is the resultant one-body potential formed, which can act on a third orbital and <code>poisson</code> computes the potential by solving Poisson&#39;s problem.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L134-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.DirectPotential" href="#Atoms.DirectPotential"><code>Atoms.DirectPotential</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DirectPotential</code></pre><p>Special case of <a href="#Atoms.HFPotential"><code>HFPotential</code></a> for the direct interaction, in which case the potential formed from two orbitals can be precomputed before acting on a third orbital.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L182-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.update!-Union{Tuple{Atoms.HFPotential{:direct,O,T,B,OV,RO,P}}, Tuple{P}, Tuple{RO}, Tuple{OV}, Tuple{B}, Tuple{T}, Tuple{O}} where P where RO where OV where B where T where O" href="#SCF.update!-Union{Tuple{Atoms.HFPotential{:direct,O,T,B,OV,RO,P}}, Tuple{P}, Tuple{RO}, Tuple{OV}, Tuple{B}, Tuple{T}, Tuple{O}} where P where RO where OV where B where T where O"><code>SCF.update!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SCF.update!(p::DirectPotential)</code></pre><p>Update the direct potential <code>p</code> by solving the Poisson problem with the current values of the orbitals forming the mutual density.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L194-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.materialize!-Union{Tuple{LazyArrays.MulAdd{#s12,#s11,#s10,T,#s9,Source,Dest} where #s9&lt;:(Atoms.HFPotential{:direct,aO,bO,T,OV,RO,P} where P where RO where OV where T where bO where aO) where #s10 where #s11 where #s12}, Tuple{Dest}, Tuple{Source}, Tuple{T}} where Dest where Source where T" href="#Base.Broadcast.materialize!-Union{Tuple{LazyArrays.MulAdd{#s12,#s11,#s10,T,#s9,Source,Dest} where #s9&lt;:(Atoms.HFPotential{:direct,aO,bO,T,OV,RO,P} where P where RO where OV where T where bO where aO) where #s10 where #s11 where #s12}, Tuple{Dest}, Tuple{Source}, Tuple{T}} where Dest where Source where T"><code>Base.Broadcast.materialize!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">materialize!(::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:AtomicOneBodyHamiltonian, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*H*x + β*y</code> where <code>H</code> is a <a href="../one_body/#Atoms.AtomicOneBodyHamiltonian"><code>AtomicOneBodyHamiltonian</code></a> and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/one_body.jl#L129-L135">source</a><div><div><pre><code class="language-none">materialize!(ma::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:DirectPotential, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*V̂*x + β*y</code> where <code>V̂</code> is a <a href="#Atoms.DirectPotential"><code>DirectPotential</code></a> (with a precomputed direct potential computed via <code>SCF.update!</code>) and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L218-L225">source</a><div><div><pre><code class="language-none">materialize!(ma::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:ExchangePotential, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*V̂*x + β*y</code> where <code>V̂</code> is a <a href="#Atoms.ExchangePotential"><code>ExchangePotential</code></a> (by solving the Poisson problem with <code>x</code> as one of the constituent source orbitals in the mutual density) and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L254-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.ExchangePotential" href="#Atoms.ExchangePotential"><code>Atoms.ExchangePotential</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ExchangePotential</code></pre><p>Special case of <a href="#Atoms.HFPotential"><code>HFPotential</code></a> for the exchange interaction, in which case the potential is formed from the orbital acted upon, along with another orbital, and then applied to a third orbital. Thus this potential <em>cannot</em> be precomputed, but must be recomputed every time the operator is applied. This makes this potential expensive to handle and the number of times it is applied should be minimized, if possible.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L231-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Broadcast.materialize!-Union{Tuple{LazyArrays.MulAdd{#s12,#s11,#s10,T,#s9,Source,Dest} where #s9&lt;:(Atoms.HFPotential{:exchange,aO,bO,T,OV,RO,P} where P where RO where OV where T where bO where aO) where #s10 where #s11 where #s12}, Tuple{Dest}, Tuple{Source}, Tuple{T}} where Dest where Source where T" href="#Base.Broadcast.materialize!-Union{Tuple{LazyArrays.MulAdd{#s12,#s11,#s10,T,#s9,Source,Dest} where #s9&lt;:(Atoms.HFPotential{:exchange,aO,bO,T,OV,RO,P} where P where RO where OV where T where bO where aO) where #s10 where #s11 where #s12}, Tuple{Dest}, Tuple{Source}, Tuple{T}} where Dest where Source where T"><code>Base.Broadcast.materialize!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">materialize!(::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:AtomicOneBodyHamiltonian, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*H*x + β*y</code> where <code>H</code> is a <a href="../one_body/#Atoms.AtomicOneBodyHamiltonian"><code>AtomicOneBodyHamiltonian</code></a> and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/one_body.jl#L129-L135">source</a><div><div><pre><code class="language-none">materialize!(ma::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:DirectPotential, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*V̂*x + β*y</code> where <code>V̂</code> is a <a href="#Atoms.DirectPotential"><code>DirectPotential</code></a> (with a precomputed direct potential computed via <code>SCF.update!</code>) and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L218-L225">source</a><div><div><pre><code class="language-none">materialize!(ma::MulAdd{&lt;:Any, &lt;:Any, &lt;:Any, T, &lt;:ExchangePotential, Source, Dest})</code></pre><p>Materialize the lazy multiplication–addition of the type <code>y ← α*V̂*x + β*y</code> where <code>V̂</code> is a <a href="#Atoms.ExchangePotential"><code>ExchangePotential</code></a> (by solving the Poisson problem with <code>x</code> as one of the constituent source orbitals in the mutual density) and <code>x</code> and <code>y</code> are <a href="../radial_orbitals/#Atoms.RadialOrbital"><code>RadialOrbital</code></a>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L254-L261">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.SourceTerm" href="#Atoms.SourceTerm"><code>Atoms.SourceTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SourceTerm(operator, source_orbital, ov)</code></pre><p>The point of <code>SourceTerm</code> is to implement inhomogeneous terms that contribute to the equation for an orbital, and whose input is some other <code>source_orbital</code>. This kind of term appears in multi-configurational problems.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L271-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.ShiftTerm" href="#Atoms.ShiftTerm"><code>Atoms.ShiftTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ShiftTerm(λ)</code></pre><p>The point of <code>ShiftTerm</code> is to implement an overall energy shift of the Hamiltonian.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_integrals.jl#L318-L323">source</a></section><h2><a class="nav-anchor" id="Orbital-equations-2" href="#Orbital-equations-2">Orbital equations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Atoms.AtomicOrbitalEquation" href="#Atoms.AtomicOrbitalEquation"><code>Atoms.AtomicOrbitalEquation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AtomicOrbitalEquation(atom, equation, orbital, ϕ, hamiltonian)</code></pre><p>Governs the evolution of an atomic <code>orbital</code> belonging to an <code>atom</code>. <code>equation</code> is the symbolic expression, from which <code>hamiltonian</code> is constructed. <code>ϕ</code> is the <code>QuasiVector</code> representing the radial orbital.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_equation.jl#L3-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.energy" href="#SCF.energy"><code>SCF.energy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SCF.energy(hfeq::AtomicOrbitalEquation[, which=:total])</code></pre><p>Compute the orbital energy for the orbital governed by <code>hfeq</code>. Optionally select which contribution is computed (<code>:total</code>, <code>:onebody</code>, <code>:direct</code>, or <code>:exchange</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/Atoms.jl/blob/6d729773f76022eefa58593744f9f9be43304c1a/src/orbital_equation.jl#L46-L52">source</a></section><footer><hr/><a class="previous" href="../hydrogenic/"><span class="direction">Previous</span><span class="title">Hydrogenic initialization</span></a><a class="next" href="../equation_systems/"><span class="direction">Next</span><span class="title">Equation systems</span></a></footer></article></body></html>
